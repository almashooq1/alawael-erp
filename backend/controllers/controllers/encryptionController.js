/**\n * Encryption Controller\n * Handles encryption, decryption, and cryptographic operations\n * Maps requests to EncryptionService methods\n */\n\nconst EncryptionService = require('../services/encryptionService');\n\nclass EncryptionController {\n  constructor() {\n    this.encryptionService = new EncryptionService();\n  }\n\n  /**\n   * Encrypt data\n   * POST /api/v1/security/encrypt\n   */\n  async encrypt(req, res, next) {\n    try {\n      const { plaintext, keyId = 'default' } = req.body;\n\n      if (!plaintext) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'Plaintext is required',\n          code: 'MISSING_PLAINTEXT'\n        });\n      }\n\n      const result = this.encryptionService.encrypt(plaintext, keyId);\n\n      res.status(201).json({\n        success: true,\n        data: {\n          encryptedId: result.id,\n          ciphertext: result.ciphertext,\n          iv: result.iv,\n          algorithm: 'aes-256-gcm',\n          keyId\n        }\n      });\n    } catch (error) {\n      if (error.message.includes('Key not found')) {\n        return res.status(400).json({\n          error: 'invalid_key',\n          message: error.message,\n          code: 'KEY_NOT_FOUND'\n        });\n      }\n      next(error);\n    }\n  }\n\n  /**\n   * Decrypt data\n   * POST /api/v1/security/decrypt\n   */\n  async decrypt(req, res, next) {\n    try {\n      const { encryptedId, keyId = 'default' } = req.body;\n\n      if (!encryptedId) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'Encrypted ID is required',\n          code: 'MISSING_ENCRYPTED_ID'\n        });\n      }\n\n      const plaintext = this.encryptionService.decrypt(encryptedId, keyId);\n\n      res.json({\n        success: true,\n        data: {\n          plaintext,\n          algorithm: 'aes-256-gcm'\n        }\n      });\n    } catch (error) {\n      if (error.message.includes('not found')) {\n        return res.status(404).json({\n          error: 'not_found',\n          message: error.message,\n          code: 'ENCRYPTED_DATA_NOT_FOUND'\n        });\n      }\n      if (error.message.includes('Failed to decrypt')) {\n        return res.status(400).json({\n          error: 'decryption_failed',\n          message: error.message,\n          code: 'DECRYPTION_ERROR'\n        });\n      }\n      next(error);\n    }\n  }\n\n  /**\n   * Hash data\n   * POST /api/v1/security/hash\n   */\n  async hash(req, res, next) {\n    try {\n      const { data, algorithm = 'sha256' } = req.body;\n\n      if (!data) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'Data is required',\n          code: 'MISSING_DATA'\n        });\n      }\n\n      const hash = this.encryptionService.hash(data, algorithm);\n\n      res.status(201).json({\n        success: true,\n        data: {\n          hash,\n          algorithm,\n          algorithm: algorithm\n        }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Hash data with salt\n   * POST /api/v1/security/hash-with-salt\n   */\n  async hashWithSalt(req, res, next) {\n    try {\n      const { data, salt } = req.body;\n\n      if (!data) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'Data is required',\n          code: 'MISSING_DATA'\n        });\n      }\n\n      const result = this.encryptionService.hashWithSalt(data, salt);\n\n      res.status(201).json({\n        success: true,\n        data: {\n          hash: result.hash,\n          salt: result.salt,\n          algorithm: 'sha256'\n        }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Verify hash\n   * POST /api/v1/security/verify-hash\n   */\n  async verifyHash(req, res, next) {\n    try {\n      const { data, hash, salt } = req.body;\n\n      if (!data || !hash) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'Data and hash are required',\n          code: 'MISSING_FIELDS'\n        });\n      }\n\n      const isValid = this.encryptionService.verifyHash(data, hash, salt);\n\n      res.json({\n        success: true,\n        data: {\n          valid: isValid\n        }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Sign data\n   * POST /api/v1/security/sign\n   */\n  async sign(req, res, next) {\n    try {\n      const { data, keyId = 'default' } = req.body;\n\n      if (!data) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'Data is required',\n          code: 'MISSING_DATA'\n        });\n      }\n\n      const signature = this.encryptionService.sign(data, keyId);\n\n      res.status(201).json({\n        success: true,\n        data: {\n          signature,\n          algorithm: 'hmac-sha256',\n          keyId\n        }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Verify signature\n   * POST /api/v1/security/verify-signature\n   */\n  async verifySignature(req, res, next) {\n    try {\n      const { data, signature, keyId = 'default' } = req.body;\n\n      if (!data || !signature) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'Data and signature are required',\n          code: 'MISSING_FIELDS'\n        });\n      }\n\n      const isValid = this.encryptionService.verifySignature(data, signature, keyId);\n\n      res.json({\n        success: true,\n        data: {\n          valid: isValid,\n          algorithm: 'hmac-sha256'\n        }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Generate key\n   * POST /api/v1/security/keys/generate\n   */\n  async generateKey(req, res, next) {\n    try {\n      const { length = 32 } = req.body;\n\n      const key = this.encryptionService.generateKey(length);\n\n      res.status(201).json({\n        success: true,\n        data: {\n          key,\n          length,\n          algorithm: 'aes-256'\n        }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Store key\n   * POST /api/v1/security/keys\n   */\n  async storeKey(req, res, next) {\n    try {\n      const { keyId, key } = req.body;\n\n      if (!keyId || !key) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'Key ID and key are required',\n          code: 'MISSING_FIELDS'\n        });\n      }\n\n      this.encryptionService.storeKey(keyId, key);\n\n      res.status(201).json({\n        success: true,\n        data: {\n          keyId,\n          message: 'Key stored successfully'\n        }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Rotate key\n   * POST /api/v1/security/keys/:keyId/rotate\n   */\n  async rotateKey(req, res, next) {\n    try {\n      const { keyId } = req.params;\n\n      const result = this.encryptionService.rotateKey(keyId);\n\n      res.json({\n        success: true,\n        data: {\n          keyId,\n          newKey: result.newKey,\n          rotatedAt: new Date(),\n          message: 'Key rotated successfully'\n        }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Generate certificate\n   * POST /api/v1/security/certificates\n   */\n  async generateCertificate(req, res, next) {\n    try {\n      const { commonName, organization, countryCode = 'US' } = req.body;\n\n      if (!commonName) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'Common name is required',\n          code: 'MISSING_CN'\n        });\n      }\n\n      const cert = this.encryptionService.generateCertificate({\n        commonName,\n        organization: organization || 'Organization',\n        countryCode\n      });\n\n      res.status(201).json({\n        success: true,\n        data: cert\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n\nmodule.exports = EncryptionController;\n