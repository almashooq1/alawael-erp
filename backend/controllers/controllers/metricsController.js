/**\n * Metrics Controller\n * Handles HTTP requests for metrics and KPI operations\n * Maps requests to MetricsService methods\n */\n\nconst MetricsService = require('../services/metricsService');\n\nclass MetricsController {\n  constructor() {\n    this.metricsService = new MetricsService();\n  }\n\n  /**\n   * Record a metric\n   * POST /api/v1/metrics\n   */\n  async recordMetric(req, res, next) {\n    try {\n      const { name, value, tags } = req.body;\n\n      if (!name || value === undefined) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'Metric name and value are required',\n          code: 'MISSING_FIELDS'\n        });\n      }\n\n      const metric = this.metricsService.recordMetric(\n        name,\n        parseFloat(value),\n        tags || {}\n      );\n\n      res.status(201).json({\n        success: true,\n        data: metric\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Get metric values\n   * GET /api/v1/metrics/:name\n   */\n  async getMetricValues(req, res, next) {\n    try {\n      const { name } = req.params;\n      const { start, end } = req.query;\n\n      if (!name) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'Metric name is required',\n          code: 'MISSING_NAME'\n        });\n      }\n\n      const startDate = start ? new Date(start) : new Date(Date.now() - 3600000);\n      const endDate = end ? new Date(end) : new Date();\n\n      const values = this.metricsService.getMetricValues(name, startDate, endDate);\n\n      res.json({\n        success: true,\n        data: values,\n        metric: name,\n        dateRange: { start: startDate, end: endDate }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Calculate metric statistics\n   * GET /api/v1/metrics/:name/stats\n   */\n  async getMetricStats(req, res, next) {\n    try {\n      const { name } = req.params;\n\n      const stats = this.metricsService.calculateMetricStats(name, {});\n\n      res.json({\n        success: true,\n        data: stats,\n        metric: name\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Define a KPI\n   * POST /api/v1/kpis\n   */\n  async defineKPI(req, res, next) {\n    try {\n      const { name, description, formula, target, unit, category } = req.body;\n\n      if (!name || !formula) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'KPI name and formula are required',\n          code: 'MISSING_FIELDS'\n        });\n      }\n\n      const kpi = this.metricsService.defineKPI(name, {\n        description: description || '',\n        formula,\n        target: target || 0,\n        unit: unit || '',\n        category: category || 'general'\n      });\n\n      res.status(201).json({\n        success: true,\n        data: kpi\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Calculate KPI status\n   * POST /api/v1/kpis/:id/calculate\n   */\n  async calculateKPI(req, res, next) {\n    try {\n      const { id } = req.params;\n      const { value } = req.body;\n\n      if (value === undefined) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'KPI value is required',\n          code: 'MISSING_VALUE'\n        });\n      }\n\n      const result = this.metricsService.calculateKPI(id, { value: parseFloat(value) });\n\n      res.json({\n        success: true,\n        data: result\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * List KPIs\n   * GET /api/v1/kpis\n   */\n  async listKPIs(req, res, next) {\n    try {\n      const { category, status } = req.query;\n\n      const filters = {};\n      if (category) filters.category = category;\n      if (status) filters.status = status;\n\n      const kpis = this.metricsService.listKPIs(filters);\n\n      res.json({\n        success: true,\n        data: kpis,\n        count: kpis.length\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Get KPI dashboard for a category\n   * GET /api/v1/kpis/dashboard/:category\n   */\n  async getKPIDashboard(req, res, next) {\n    try {\n      const { category } = req.params;\n\n      const dashboard = this.metricsService.getKPIDashboard(category);\n\n      res.json({\n        success: true,\n        data: dashboard,\n        category\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Get metric trend\n   * GET /api/v1/metrics/:name/trend\n   */\n  async getMetricTrend(req, res, next) {\n    try {\n      const { name } = req.params;\n      const { periods = 12 } = req.query;\n\n      const trend = this.metricsService.getMetricTrend(name, parseInt(periods));\n\n      res.json({\n        success: true,\n        data: trend,\n        metric: name,\n        periods: parseInt(periods)\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  /**\n   * Compare multiple metrics\n   * POST /api/v1/metrics/compare\n   */\n  async compareMetrics(req, res, next) {\n    try {\n      const { metricNames, start, end } = req.body;\n\n      if (!metricNames || !Array.isArray(metricNames)) {\n        return res.status(400).json({\n          error: 'validation_error',\n          message: 'Metric names array is required',\n          code: 'INVALID_METRICS'\n        });\n      }\n\n      const startDate = start ? new Date(start) : new Date(Date.now() - 86400000);\n      const endDate = end ? new Date(end) : new Date();\n\n      const comparison = this.metricsService.compareMetrics(\n        metricNames,\n        startDate,\n        endDate\n      );\n\n      res.json({\n        success: true,\n        data: comparison,\n        metricsCount: metricNames.length,\n        dateRange: { start: startDate, end: endDate }\n      });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n\nmodule.exports = MetricsController;\n