/**
 * Authentication Middleware
 * Basic auth middleware for protected routes
 */

const jwt = require('jwt-simple');
const logger = require('../utils/logger');

const SECRET = process.env.JWT_SECRET || 'your-secret-key';

/**
 * Verify JWT token
 */
const verifyToken = (req, res, next) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];

    if (!token) {
      return res.status(401).json({ success: false, error: 'No token provided' });
    }

    // Decode base64 token (as generated by AuthService)
    let decoded;
    try {
      decoded = JSON.parse(Buffer.from(token, 'base64').toString());
    } catch (_e) {
      // If base64 decoding fails, try JWT
      try {
        decoded = jwt.decode(token, SECRET);
      } catch (_jwtError) {
        // If both fail, return invalid token error
        return res.status(401).json({ success: false, error: 'Invalid token' });
      }
    }

    if (decoded.exp && decoded.exp < Date.now()) {
      return res.status(401).json({ success: false, error: 'Token expired' });
    }

    req.user = decoded;
    next();
  } catch (error) {
    logger.error('Token verification failed:', error);
    res.status(401).json({ success: false, error: 'Invalid token' });
  }
};

/**
 * Optional authentication - doesn't fail if no token
 */
const optionalAuth = (req, res, next) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];

    if (token) {
      // Decode base64 token (as generated by AuthService)
      let decoded;
      try {
        decoded = JSON.parse(Buffer.from(token, 'base64').toString());
      } catch (_e) {
        // Try JWT decoding as fallback
        try {
          decoded = jwt.decode(token, SECRET);
        } catch (_jwtError) {
          // If both fail, just continue without user
          return next();
        }
      }

      if (!decoded.exp || decoded.exp >= Date.now()) {
        req.user = decoded;
      }
    }

    next();
  } catch (error) {
    logger.debug('Optional auth failed:', error.message);
    next();
  }
};

/**
 * Admin authorization
 */

// RBAC متقدم: تحقق من الدور والصلاحيات والسياق المؤسسي/الفرعي
const requireAdmin = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  // تحقق من الدور الأساسي أو الأدوار الإضافية
  const isAdmin =
    req.user.role === 'admin' ||
    (Array.isArray(req.user.roles) && req.user.roles.includes('admin'));
  if (!isAdmin) {
    return res.status(403).json({ error: 'Admin access required' });
  }
  // تحقق من المؤسسة/الفرع إذا تم تمرير orgId/branchId في الطلب
  if (req.params.orgId && req.user.organizationId && req.params.orgId !== req.user.organizationId) {
    return res.status(403).json({ error: 'Access denied for this organization' });
  }
  if (req.params.branchId && req.user.branchId && req.params.branchId !== req.user.branchId) {
    return res.status(403).json({ error: 'Access denied for this branch' });
  }
  next();
};

// ميدل وير لصلاحيات granular (permission string)
const requirePermission = permission => (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  // تحقق من الصلاحيات
  const hasPermission =
    Array.isArray(req.user.permissions) && req.user.permissions.includes(permission);
  if (!hasPermission) {
    return res.status(403).json({ error: 'Permission denied' });
  }
  // تحقق من المؤسسة/الفرع إذا لزم
  if (req.params.orgId && req.user.organizationId && req.params.orgId !== req.user.organizationId) {
    return res.status(403).json({ error: 'Access denied for this organization' });
  }
  if (req.params.branchId && req.user.branchId && req.params.branchId !== req.user.branchId) {
    return res.status(403).json({ error: 'Access denied for this branch' });
  }
  next();
};

/**
 * Authenticate middleware (alias for verifyToken)
 */
const authenticate = verifyToken;

/**
 * Authorization middleware - checks multiple roles
 */
const authorize =
  (...allowedRoles) =>
  (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Not authenticated' });
    }

    if (allowedRoles.length > 0 && !allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }

    next();
  };

module.exports = {
  verifyToken,
  optionalAuth,
  requireAdmin,
  requirePermission,
  authenticate,
  authorize,
  protect: verifyToken, // Alias for backward compatibility
};
