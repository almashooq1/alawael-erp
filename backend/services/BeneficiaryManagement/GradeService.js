// backend/services/BeneficiaryManagement/GradeService.js\n\n/**\n * خدمة إدارة الدرجات والتقييم\n * Grade & Assessment Management Service\n */\n\nconst mongoose = require('mongoose');\n\nclass GradeService {\n  \n  constructor(db) {\n    this.db = db;\n  }\n\n  /**\n   * تسجيل الدرجات\n   */\n  async recordGrade(enrollmentId, courseId, gradeData) {\n    try {\n      const enrollmentObjectId = new mongoose.Types.ObjectId(enrollmentId);\n      const courseObjectId = new mongoose.Types.ObjectId(courseId);\n      \n      // التحقق من صحة البيانات\n      if (gradeData.grade < 0 || gradeData.grade > 4) {\n        throw new Error('Grade must be between 0 and 4');\n      }\n      \n      // جلب التسجيل والمقرر\n      const enrollment = await this.db.collection('enrollments').findOne({\n        _id: enrollmentObjectId\n      });\n      const course = await this.db.collection('courses').findOne({\n        _id: courseObjectId\n      });\n      \n      if (!enrollment || !course) {\n        throw new Error('Enrollment or Course not found');\n      }\n      \n      // إنشاء سجل الدرجة\n      const grade = {\n        enrollmentId: enrollmentObjectId,\n        beneficiaryId: enrollment.beneficiaryId,\n        courseId: courseObjectId,\n        courseName: course.name,\n        credits: course.credits,\n        grade: gradeData.grade,\n        letterGrade: this.getLetterGrade(gradeData.grade),\n        gradePoints: gradeData.grade * course.credits,\n        status: gradeData.grade >= 2.0 ? 'passed' : 'failed',\n        semesterId: gradeData.semesterId,\n        gradingDate: new Date(),\n        gradedBy: gradeData.gradedBy || null,\n        comments: gradeData.comments || '',\n        createdAt: new Date()\n      };\n      \n      // حفظ الدرجة\n      const result = await this.db.collection('grades').insertOne(grade);\n      \n      // تحديث المعدل التراكمي\n      await this.updateCumulativeGPA(enrollment.beneficiaryId);\n      \n      return result.insertedId;\n      \n    } catch (error) {\n      throw new Error(`Grade recording failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * حساب المعدل التراكمي (GPA)\n   */\n  async calculateGPA(beneficiaryId, period = 'cumulative') {\n    try {\n      const beneficiaryObjectId = new mongoose.Types.ObjectId(beneficiaryId);\n      \n      let query = { beneficiaryId: beneficiaryObjectId };\n      \n      // إضافة فلتر الفترة إن لزم الأمر\n      if (period !== 'cumulative') {\n        const dateFilter = this.getDateRangeForPeriod(period);\n        query.gradingDate = dateFilter;\n      }\n      \n      // جلب جميع الدرجات\n      const grades = await this.db.collection('grades').find(query).toArray();\n      \n      if (grades.length === 0) {\n        return { gpa: 0, credits: 0, courses: 0 };\n      }\n      \n      // حساب المتوسط المرجح\n      const totalGradePoints = grades.reduce((sum, g) => sum + g.gradePoints, 0);\n      const totalCredits = grades.reduce((sum, g) => sum + g.credits, 0);\n      const gpa = (totalGradePoints / totalCredits).toFixed(2);\n      \n      // مقارنة مع الفترات السابقة\n      const previousGPA = await this.getPreviousPeriodGPA(beneficiaryId, period);\n      const trend = previousGPA ? (gpa - previousGPA).toFixed(2) : null;\n      \n      return {\n        gpa: parseFloat(gpa),\n        totalGradePoints,\n        totalCredits,\n        courierCount: grades.length,\n        period,\n        previousGPA,\n        trend: trend ? (trend > 0 ? 'up' : 'down') : null,\n        trendValue: trend\n      };\n      \n    } catch (error) {\n      throw new Error(`GPA calculation failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * إصدار النسخة الأكاديمية (Transcript)\n   */\n  async generateTranscript(beneficiaryId) {\n    try {\n      const beneficiaryObjectId = new mongoose.Types.ObjectId(beneficiaryId);\n      \n      // جلب بيانات المستفيد\n      const beneficiary = await this.db.collection('beneficiaries').findOne({\n        _id: beneficiaryObjectId\n      });\n      \n      // جلب جميع الدرجات\n      const grades = await this.db.collection('grades')\n        .find({ beneficiaryId: beneficiaryObjectId })\n        .sort({ gradingDate: 1 })\n        .toArray();\n      \n      // حساب المعدل التراكمي\n      const gpaInfo = await this.calculateGPA(beneficiaryId);\n      \n      // تحديد الفئة التقديرية\n      const classification = this.getAcademicClassification(gpaInfo.gpa);\n      \n      // إنشاء النسخة الأكاديمية\n      const transcript = {\n        beneficiaryId: beneficiaryObjectId,\n        documentNumber: this.generateDocumentNumber(),\n        issue_date: new Date(),\n        validityDate: new Date(new Date().setFullYear(new Date().getFullYear() + 4)),\n        \n        personalInfo: {\n          name: `${beneficiary.personalData.firstName} ${beneficiary.personalData.lastName}`,\n          idNumber: beneficiary.personalData.idNumber,\n          email: beneficiary.personalData.email,\n          dateOfBirth: beneficiary.personalData.dateOfBirth\n        },\n        \n        academicInfo: {\n          program: beneficiary.academicInfo.currentProgram,\n          majorSpecialization: beneficiary.academicInfo.majorSpecialization,\n          dateOfEntry: beneficiary.createdAt,\n          status: beneficiary.academicInfo.status\n        },\n        \n        academicRecord: grades.map(g => ({\n          courseCode: g.courseId,\n          courseName: g.courseName,\n          credits: g.credits,\n          grade: g.grade,\n          letterGrade: g.letterGrade,\n          semester: g.semesterId\n        })),\n        \n        summary: {\n          totalCoursesCompleted: grades.length,\n          totalCreditsEarned: gpaInfo.totalCredits,\n          cumulativeGPA: gpaInfo.gpa,\n          academicClassification: classification,\n          passingPercentage: ((grades.filter(g => g.status === 'passed').length / grades.length) * 100).toFixed(2)\n        },\n        \n        signature: {\n          registrar: 'Authorized Registrar',\n          date: new Date(),\n          seal: 'Official University Seal'\n        }\n      };\n      \n      // حفظ النسخة\n      const result = await this.db.collection('transcripts').insertOne(transcript);\n      \n      return transcript;\n      \n    } catch (error) {\n      throw new Error(`Transcript generation failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * تحليل النمط الأكاديمي\n   */\n  async analyzeAcademicPattern(beneficiaryId) {\n    try {\n      const beneficiaryObjectId = new mongoose.Types.ObjectId(beneficiaryId);\n      \n      // جلب جميع الدرجات\n      const grades = await this.db.collection('grades').find({\n        beneficiaryId: beneficiaryObjectId\n      }).toArray();\n      \n      if (grades.length === 0) {\n        return { message: 'No grades found' };\n      }\n      \n      // تحليل البيانات\n      const strongCourses = grades.filter(g => g.grade >= 3.5).map(g => g.courseName);\n      const weakCourses = grades.filter(g => g.grade < 2.0).map(g => g.courseName);\n      const averageCourses = grades.filter(g => g.grade >= 2.0 && g.grade < 3.5).map(g => g.courseName);\n      \n      // حساب الاتجاهات\n      const recentGrades = grades.slice(-5);\n      const recentAverage = (recentGrades.reduce((sum, g) => sum + g.grade, 0) / recentGrades.length).toFixed(2);\n      \n      const oldGrades = grades.slice(0, 5);\n      const oldAverage = oldGrades.length > 0\n        ? (oldGrades.reduce((sum, g) => sum + g.grade, 0) / oldGrades.length).toFixed(2)\n        : null;\n      \n      const trend = oldAverage ? (recentAverage - oldAverage).toFixed(2) : null;\n      const direction = trend > 0 ? 'improving' : trend < 0 ? 'declining' : 'stable';\n      \n      // التوصيات\n      const recommendations = [];\n      if (weakCourses.length > 0) {\n        recommendations.push(`Focus on improving: ${weakCourses.join(', ')}`);\n        recommendations.push('Consider tutoring support for these subjects');\n      }\n      if (direction === 'declining') {\n        recommendations.push('Recent performance is declining - seek academic support');\n      }\n      if (strongCourses.length > 0) {\n        recommendations.push(`Build on your strengths in: ${strongCourses.join(', ')}`);\n      }\n      \n      return {\n        beneficiaryId,\n        strongCourses,\n        weakCourses,\n        averageCourses,\n        trends: {\n          recentAverage: parseFloat(recentAverage),\n          historicalAverage: parseFloat(oldAverage),\n          change: parseFloat(trend),\n          direction\n        },\n        recommendations,\n        analyzedAt: new Date()\n      };\n      \n    } catch (error) {\n      throw new Error(`Pattern analysis failed: ${error.message}`);\n    }\n  }\n\n  // Helper Methods\n  \n  getLetterGrade(grade) {\n    if (grade >= 3.7) return 'A';\n    if (grade >= 3.3) return 'A-';\n    if (grade >= 3.0) return 'B+';\n    if (grade >= 2.7) return 'B';\n    if (grade >= 2.3) return 'B-';\n    if (grade >= 2.0) return 'C';\n    if (grade >= 1.3) return 'D';\n    return 'F';\n  }\n\n  getAcademicClassification(gpa) {\n    if (gpa >= 3.7) return 'Summa Cum Laude';\n    if (gpa >= 3.5) return 'Magna Cum Laude';\n    if (gpa >= 3.3) return 'Cum Laude';\n    if (gpa >= 3.0) return 'First Class';\n    if (gpa >= 2.5) return 'Second Class';\n    if (gpa >= 2.0) return 'Third Class';\n    return 'Pass';\n  }\n\n  async updateCumulativeGPA(beneficiaryId) {\n    const gpaInfo = await this.calculateGPA(beneficiaryId);\n    \n    await this.db.collection('beneficiaries').updateOne(\n      { _id: beneficiaryId },\n      {\n        $set: {\n          'performanceMetrics.cumulativeGPA': gpaInfo.gpa,\n          'performanceMetrics.lastUpdated': new Date()\n        }\n      }\n    );\n  }\n\n  getDateRangeForPeriod(period) {\n    const now = new Date();\n    let startDate;\n    \n    switch (period) {\n      case 'semester':\n        startDate = new Date(now.getFullYear(), now.getMonth() - 4, 1);\n        break;\n      case 'year':\n        startDate = new Date(now.getFullYear(), 0, 1);\n        break;\n      default:\n        return {};\n    }\n    \n    return { $gte: startDate, $lte: now };\n  }\n\n  async getPreviousPeriodGPA(beneficiaryId, currentPeriod) {\n    // Logic to get previous period GPA\n    return null;\n  }\n\n  generateDocumentNumber() {\n    return `TRAN-${Date.now()}-${Math.random().toString(36).substr(2, 9).toUpperCase()}`;\n  }\n}\n\nmodule.exports = GradeService;\n
