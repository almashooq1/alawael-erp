/**\n * Metrics Service - Phase 10 Analytics Metrics & KPI\n * Manages metrics collection, calculation, and analysis\n */\n\nconst crypto = require('crypto');\n\nclass MetricsService {\n  constructor() {\n    this.metrics = new Map();\n    this.kpis = new Map();\n    this.aggregations = new Map();\n  }\n\n  /**\n   * Record metric value\n   * @param {string} metricName - Metric name\n   * @param {number|Object} value - Metric value\n   * @param {Object} tags - Tag metadata\n   * @returns {Object} Recorded metric\n   */\n  recordMetric(metricName, value, tags = {}) {\n    if (!this.metrics.has(metricName)) {\n      this.metrics.set(metricName, []);\n    }\n\n    const metricData = {\n      id: crypto.randomUUID(),\n      name: metricName,\n      value,\n      tags,\n      timestamp: new Date(),\n      _ttl: Date.now() + 86400000 // 24 hour TTL\n    };\n\n    this.metrics.get(metricName).push(metricData);\n    return metricData;\n  }\n\n  /**\n   * Get metric values within time range\n   * @param {string} metricName - Metric name\n   * @param {Date} startDate - Start date\n   * @param {Date} endDate - End date\n   * @returns {Array} Metric values\n   */\n  getMetricValues(metricName, startDate, endDate) {\n    const values = this.metrics.get(metricName) || [];\n    return values.filter(m => m.timestamp >= startDate && m.timestamp <= endDate);\n  }\n\n  /**\n   * Calculate metric statistics\n   * @param {string} metricName - Metric name\n   * @param {Object} options - Options for calculation\n   * @returns {Object} Statistics\n   */\n  calculateMetricStats(metricName, options = {}) {\n    const values = this.metrics.get(metricName) || [];\n    const numericValues = values.map(m => parseFloat(m.value)).filter(v => !isNaN(v));\n\n    if (numericValues.length === 0) {\n      return { count: 0, error: 'No numeric values found' };\n    }\n\n    const sum = numericValues.reduce((a, b) => a + b, 0);\n    const avg = sum / numericValues.length;\n    const min = Math.min(...numericValues);\n    const max = Math.max(...numericValues);\n    const variance = numericValues.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / numericValues.length;\n    const stdDev = Math.sqrt(variance);\n\n    return {\n      count: numericValues.length,\n      sum: parseFloat(sum.toFixed(2)),\n      average: parseFloat(avg.toFixed(2)),\n      min: parseFloat(min.toFixed(2)),\n      max: parseFloat(max.toFixed(2)),\n      stdDev: parseFloat(stdDev.toFixed(2)),\n      variance: parseFloat(variance.toFixed(2)),\n      latest: values[values.length - 1]?.value || null\n    };\n  }\n\n  /**\n   * Define KPI\n   * @param {string} kpiName - KPI name\n   * @param {Object} definition - KPI definition\n   * @returns {Object} Created KPI\n   */\n  defineKPI(kpiName, definition) {\n    const kpiId = crypto.randomUUID();\n    const kpi = {\n      id: kpiId,\n      name: kpiName,\n      description: definition.description || '',\n      formula: definition.formula || null,\n      target: definition.target || null,\n      threshold: definition.threshold || { warning: 80, critical: 60 },\n      unit: definition.unit || '',\n      frequency: definition.frequency || 'daily', // daily, weekly, monthly\n      category: definition.category || 'general',\n      owner: definition.owner || null,\n      lastCalculated: null,\n      currentValue: null,\n      status: 'unknown', // on-track, at-risk, off-track\n      created_at: new Date()\n    };\n\n    this.kpis.set(kpiId, kpi);\n    return kpi;\n  }\n\n  /**\n   * Calculate KPI value\n   * @param {string} kpiId - KPI ID\n   * @param {Object} dataContext - Data for calculation\n   * @returns {Object} KPI result\n   */\n  calculateKPI(kpiId, dataContext) {\n    const kpi = this.kpis.get(kpiId);\n    if (!kpi) throw new Error(`KPI ${kpiId} not found`);\n\n    let currentValue = 0;\n    let status = 'unknown';\n\n    if (kpi.formula) {\n      // Execute formula with data context\n      currValue = this._evaluateFormula(kpi.formula, dataContext);\n    } else if (dataContext.value !== undefined) {\n      currentValue = dataContext.value;\n    }\n\n    // Determine status\n    if (kpi.target) {\n      const percentage = (currentValue / kpi.target) * 100;\n      if (percentage >= kpi.threshold.warning) {\n        status = 'on-track';\n      } else if (percentage >= kpi.threshold.critical) {\n        status = 'at-risk';\n      } else {\n        status = 'off-track';\n      }\n    }\n\n    kpi.lastCalculated = new Date();\n    kpi.currentValue = currentValue;\n    kpi.status = status;\n\n    return {\n      kpiId,\n      name: kpi.name,\n      value: currentValue,\n      target: kpi.target,\n      percentage: kpi.target ? ((currentValue / kpi.target) * 100).toFixed(2) : null,\n      status,\n      unit: kpi.unit,\n      calculatedAt: kpi.lastCalculated\n    };\n  }\n\n  /**\n   * Get all KPIs\n   * @param {Object} filters - Filter options\n   * @returns {Array} List of KPIs\n   */\n  listKPIs(filters = {}) {\n    let kpis = Array.from(this.kpis.values());\n\n    if (filters.category) {\n      kpis = kpis.filter(k => k.category === filters.category);\n    }\n    if (filters.status) {\n      kpis = kpis.filter(k => k.status === filters.status);\n    }\n\n    return kpis.sort((a, b) => b.lastCalculated - a.lastCalculated);\n  }\n\n  /**\n   * Get KPI dashboard\n   * @param {string} category - Category filter\n   * @returns {Object} KPI dashboard data\n   */\n  getKPIDashboard(category = null) {\n    let kpis = Array.from(this.kpis.values());\n\n    if (category) {\n      kpis = kpis.filter(k => k.category === category);\n    }\n\n    const statusCounts = {\n      'on-track': 0,\n      'at-risk': 0,\n      'off-track': 0,\n      'unknown': 0\n    };\n\n    kpis.forEach(kpi => {\n      statusCounts[kpi.status]++;\n    });\n\n    return {\n      totalKPIs: kpis.length,\n      statusCounts,\n      kpis: kpis.map(k => ({\n        id: k.id,\n        name: k.name,\n        value: k.currentValue,\n        target: k.target,\n        percentage: k.target ? ((k.currentValue / k.target) * 100).toFixed(2) : null,\n        status: k.status,\n        unit: k.unit,\n        lastUpdated: k.lastCalculated\n      })),\n      generatedAt: new Date()\n    };\n  }\n\n  /**\n   * Get metric trend\n   * @param {string} metricName - Metric name\n   * @param {number} periods - Number of periods\n   * @returns {Array} Trend data\n   */\n  getMetricTrend(metricName, periods = 30) {\n    const values = this.metrics.get(metricName) || [];\n    const endDate = new Date();\n    const startDate = new Date(endDate.getTime() - periods * 24 * 60 * 60 * 1000);\n\n    return values\n      .filter(m => m.timestamp >= startDate && m.timestamp <= endDate)\n      .map(m => ({\n        timestamp: m.timestamp,\n        value: m.value,\n        tags: m.tags\n      }))\n      .sort((a, b) => a.timestamp - b.timestamp);\n  }\n\n  /**\n   * Compare metrics\n   * @param {Array} metricNames - Metric names\n   * @param {Date} startDate - Start date\n   * @param {Date} endDate - End date\n   * @returns {Object} Comparison results\n   */\n  compareMetrics(metricNames, startDate, endDate) {\n    const comparison = {};\n\n    metricNames.forEach(name => {\n      const values = this.getMetricValues(name, startDate, endDate);\n      const stats = this.calculateMetricStats(name, { startDate, endDate });\n      comparison[name] = {\n        stats,\n        trend: values.map(v => ({ timestamp: v.timestamp, value: v.value }))\n      };\n    });\n\n    return comparison;\n  }\n\n  /**\n   * Evaluate formula\n   * @private\n   */\n  _evaluateFormula(formula, context) {\n    // Safe formula evaluation with context variables\n    const variables = Object.keys(context).join(', ');\n    const functionBody = `return ${formula}`;\n    const func = new Function(variables, functionBody);\n    return func(...Object.values(context));\n  }\n}\n\nmodule.exports = new MetricsService();\n