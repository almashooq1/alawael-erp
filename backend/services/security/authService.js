/**\n * Authentication Service - Phase 11 Security & Compliance\n * Handles user authentication, session management, and token generation\n */\n\nconst crypto = require('crypto');\n\nclass AuthService {\n  constructor() {\n    this.users = new Map();\n    this.sessions = new Map();\n    this.tokens = new Map();\n  }\n\n  /**\n   * Register new user\n   * @param {Object} userData - User data\n   * @returns {Object} Created user\n   */\n  registerUser(userData) {\n    const userId = crypto.randomUUID();\n    const salt = crypto.randomBytes(16).toString('hex');\n    const passwordHash = this._hashPassword(userData.password, salt);\n\n    const user = {\n      id: userId,\n      username: userData.username,\n      email: userData.email,\n      passwordHash,\n      salt,\n      twoFactorEnabled: false,\n      twoFactorSecret: null,\n      lastLogin: null,\n      loginAttempts: 0,\n      lockedUntil: null,\n      status: 'active',\n      roles: userData.roles || [],\n      permissions: userData.permissions || [],\n      metadata: userData.metadata || {},\n      created_at: new Date(),\n      updated_at: new Date()\n    };\n\n    this.users.set(userId, user);\n    return this._sanitizeUser(user);\n  }\n\n  /**\n   * Authenticate user\n   * @param {string} username - Username or email\n   * @param {string} password - Password\n   * @returns {Object} Authentication result\n   */\n  authenticateUser(username, password) {\n    const user = Array.from(this.users.values()).find(\n      u => u.username === username || u.email === username\n    );\n\n    if (!user) {\n      return { success: false, error: 'User not found' };\n    }\n\n    // Check if account is locked\n    if (user.lockedUntil && user.lockedUntil > new Date()) {\n      return { success: false, error: 'Account is locked' };\n    }\n\n    // Verify password\n    const passwordHash = this._hashPassword(password, user.salt);\n    if (passwordHash !== user.passwordHash) {\n      user.loginAttempts++;\n      if (user.loginAttempts >= 5) {\n        user.lockedUntil = new Date(Date.now() + 15 * 60 * 1000); // Lock for 15 minutes\n      }\n      return { success: false, error: 'Invalid password' };\n    }\n\n    // Reset login attempts\n    user.loginAttempts = 0;\n    user.lockedUntil = null;\n    user.lastLogin = new Date();\n\n    // Create session and tokens\n    const sessionId = crypto.randomUUID();\n    const accessToken = this._generateToken(user.id, 'access', 3600); // 1 hour\n    const refreshToken = this._generateToken(user.id, 'refresh', 604800); // 7 days\n\n    const session = {\n      id: sessionId,\n      userId: user.id,\n      accessToken,\n      refreshToken,\n      expiresAt: new Date(Date.now() + 3600000),\n      refreshExpiresAt: new Date(Date.now() + 604800000),\n      ipAddress: null,\n      userAgent: null,\n      created_at: new Date()\n    };\n\n    this.sessions.set(sessionId, session);\n    this.tokens.set(accessToken, { userId: user.id, type: 'access' });\n    this.tokens.set(refreshToken, { userId: user.id, type: 'refresh' });\n\n    return {\n      success: true,\n      sessionId,\n      accessToken,\n      refreshToken,\n      user: this._sanitizeUser(user)\n    };\n  }\n\n  /**\n   * Verify token\n   * @param {string} token - Token to verify\n   * @returns {Object} Token verification result\n   */\n  verifyToken(token) {\n    const tokenData = this.tokens.get(token);\n\n    if (!tokenData) {\n      return { valid: false, error: 'Token not found' };\n    }\n\n    const user = this.users.get(tokenData.userId);\n    if (!user) {\n      return { valid: false, error: 'User not found' };\n    }\n\n    return {\n      valid: true,\n      userId: user.id,\n      username: user.username,\n      roles: user.roles,\n      permissions: user.permissions\n    };\n  }\n\n  /**\n   * Refresh access token\n   * @param {string} refreshToken - Refresh token\n   * @returns {Object} New tokens\n   */\n  refreshAccessToken(refreshToken) {\n    const tokenData = this.tokens.get(refreshToken);\n\n    if (!tokenData || tokenData.type !== 'refresh') {\n      return { success: false, error: 'Invalid refresh token' };\n    }\n\n    // Check if refresh token session is still valid\n    const session = Array.from(this.sessions.values()).find(\n      s => s.refreshToken === refreshToken && s.refreshExpiresAt > new Date()\n    );\n\n    if (!session) {\n      return { success: false, error: 'Refresh token expired' };\n    }\n\n    // Generate new tokens\n    const newAccessToken = this._generateToken(tokenData.userId, 'access', 3600);\n    const newRefreshToken = this._generateToken(tokenData.userId, 'refresh', 604800);\n\n    // Update tokens\n    this.tokens.delete(session.accessToken);\n    this.tokens.set(newAccessToken, { userId: tokenData.userId, type: 'access' });\n    this.tokens.set(newRefreshToken, { userId: tokenData.userId, type: 'refresh' });\n\n    session.accessToken = newAccessToken;\n    session.refreshToken = newRefreshToken;\n    session.expiresAt = new Date(Date.now() + 3600000);\n    session.refreshExpiresAt = new Date(Date.now() + 604800000);\n\n    return {\n      success: true,\n      accessToken: newAccessToken,\n      refreshToken: newRefreshToken\n    };\n  }\n\n  /**\n   * Logout user\n   * @param {string} sessionId - Session ID\n   * @returns {boolean} Success\n   */\n  logoutUser(sessionId) {\n    const session = this.sessions.get(sessionId);\n    if (!session) return false;\n\n    this.tokens.delete(session.accessToken);\n    this.tokens.delete(session.refreshToken);\n    return this.sessions.delete(sessionId);\n  }\n\n  /**\n   * Enable 2FA\n   * @param {string} userId - User ID\n   * @returns {Object} 2FA setup data\n   */\n  enableTwoFactor(userId) {\n    const user = this.users.get(userId);\n    if (!user) throw new Error('User not found');\n\n    const secret = crypto.randomBytes(20).toString('hex');\n    user.twoFactorSecret = secret;\n    user.twoFactorEnabled = false; // Enabled after verification\n\n    return {\n      secret,\n      qrCode: `otpauth://totp/App:${user.email}?secret=${secret}`,\n      backupCodes: this._generateBackupCodes(10)\n    };\n  }\n\n  /**\n   * Verify 2FA\n   * @param {string} userId - User ID\n   * @param {string} code - 2FA code\n   * @returns {Object} Verification result\n   */\n  verifyTwoFactor(userId, code) {\n    const user = this.users.get(userId);\n    if (!user) return { success: false, error: 'User not found' };\n\n    // Mock verification (in production, use totp library)\n    const isValid = code.length === 6 && /^\\d+$/.test(code);\n\n    if (isValid) {\n      user.twoFactorEnabled = true;\n      return { success: true };\n    }\n\n    return { success: false, error: 'Invalid code' };\n  }\n\n  /**\n   * Reset password\n   * @param {string} email - User email\n   * @returns {Object} Password reset token\n   */\n  resetPassword(email) {\n    const user = Array.from(this.users.values()).find(u => u.email === email);\n    if (!user) return { success: false, error: 'User not found' };\n\n    const resetToken = crypto.randomBytes(32).toString('hex');\n    user.passwordResetToken = resetToken;\n    user.passwordResetExpiry = new Date(Date.now() + 3600000); // 1 hour\n\n    return {\n      success: true,\n      resetToken,\n      expiresAt: user.passwordResetExpiry\n    };\n  }\n\n  /**\n   * Update password\n   * @param {string} userId - User ID\n   * @param {string} currentPassword - Current password\n   * @param {string} newPassword - New password\n   * @returns {Object} Update result\n   */\n  updatePassword(userId, currentPassword, newPassword) {\n    const user = this.users.get(userId);\n    if (!user) return { success: false, error: 'User not found' };\n\n    // Verify current password\n    const currentHash = this._hashPassword(currentPassword, user.salt);\n    if (currentHash !== user.passwordHash) {\n      return { success: false, error: 'Current password is incorrect' };\n    }\n\n    // Update password\n    const newSalt = crypto.randomBytes(16).toString('hex');\n    user.passwordHash = this._hashPassword(newPassword, newSalt);\n    user.salt = newSalt;\n\n    return { success: true };\n  }\n\n  /**\n   * Hash password\n   * @private\n   */\n  _hashPassword(password, salt) {\n    return crypto.createHash('sha256').update(password + salt).digest('hex');\n  }\n\n  /**\n   * Generate JWT-like token\n   * @private\n   */\n  _generateToken(userId, type, expiresIn) {\n    const payload = {\n      sub: userId,\n      type,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + expiresIn\n    };\n    return crypto.randomBytes(32).toString('hex');\n  }\n\n  /**\n   * Generate backup codes\n   * @private\n   */\n  _generateBackupCodes(count) {\n    const codes = [];\n    for (let i = 0; i < count; i++) {\n      codes.push(crypto.randomBytes(4).toString('hex').toUpperCase());\n    }\n    return codes;\n  }\n\n  /**\n   * Sanitize user (remove sensitive data)\n   * @private\n   */\n  _sanitizeUser(user) {\n    const { passwordHash, salt, twoFactorSecret, ...sanitized } = user;\n    return sanitized;\n  }\n}\n\nmodule.exports = new AuthService();\n