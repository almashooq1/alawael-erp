/**\n * Encryption Service - Phase 11 Data Security\n * Handles encryption, decryption, and key management\n */\n\nconst crypto = require('crypto');\n\nclass EncryptionService {\n  constructor() {\n    this.encryptedData = new Map();\n    this.keyStore = new Map();\n    this._initializeKeys();\n  }\n\n  /**\n   * Encrypt data\n   * @param {string} plaintext - Data to encrypt\n   * @param {string} keyId - Key ID (optional, uses default)\n   * @returns {Object} Encrypted data\n   */\n  encrypt(plaintext, keyId = 'default') {\n    const key = this.keyStore.get(keyId);\n    if (!key) throw new Error(`Key ${keyId} not found`);\n\n    const iv = crypto.randomBytes(16);\n    const encryptedId = crypto.randomUUID();\n\n    const cipher = crypto.createCipheriv('aes-256-gcm', Buffer.from(key, 'hex'), iv);\n    const encrypted = cipher.update(plaintext, 'utf8', 'hex') + cipher.final('hex');\n    const authTag = cipher.getAuthTag().toString('hex');\n\n    const encryptedData = {\n      id: encryptedId,\n      encrypted,\n      iv: iv.toString('hex'),\n      authTag,\n      algorithm: 'aes-256-gcm',\n      keyId,\n      createdAt: new Date()\n    };\n\n    this.encryptedData.set(encryptedId, encryptedData);\n\n    return {\n      encryptedId,\n      ciphertext: encrypted,\n      iv: iv.toString('hex'),\n      authTag\n    };\n  }\n\n  /**\n   * Decrypt data\n   * @param {string} encryptedId - Encrypted data ID\n   * @param {string} keyId - Key ID\n   * @returns {string} Decrypted plaintext\n   */\n  decrypt(encryptedId, keyId = 'default') {\n    const encryptedData = this.encryptedData.get(encryptedId);\n    if (!encryptedData) throw new Error(`Encrypted data ${encryptedId} not found`);\n\n    const key = this.keyStore.get(keyId);\n    if (!key) throw new Error(`Key ${keyId} not found`);\n\n    const iv = Buffer.from(encryptedData.iv, 'hex');\n    const authTag = Buffer.from(encryptedData.authTag, 'hex');\n\n    const decipher = crypto.createDecipheriv('aes-256-gcm', Buffer.from(key, 'hex'), iv);\n    decipher.setAuthTag(authTag);\n\n    const decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8') + decipher.final('utf8');\n\n    return decrypted;\n  }\n\n  /**\n   * Hash data (one-way)\n   * @param {string} data - Data to hash\n   * @param {string} algorithm - Hash algorithm\n   * @returns {string} Hash\n   */\n  hash(data, algorithm = 'sha256') {\n    return crypto.createHash(algorithm).update(data).digest('hex');\n  }\n\n  /**\n   * Hash with salt\n   * @param {string} data - Data to hash\n   * @param {string} salt - Salt (or generates new)\n   * @returns {Object} Hashed data with salt\n   */\n  hashWithSalt(data, salt = null) {\n    const newSalt = salt || crypto.randomBytes(16).toString('hex');\n    const hashed = crypto.createHash('sha256').update(data + newSalt).digest('hex');\n\n    return { hashed, salt: newSalt };\n  }\n\n  /**\n   * Verify hash\n   * @param {string} data - Original data\n   * @param {string} hash - Hash to verify\n   * @param {string} salt - Salt used\n   * @returns {boolean} Verification result\n   */\n  verifyHash(data, hash, salt) {\n    const computed = crypto.createHash('sha256').update(data + salt).digest('hex');\n    return computed === hash;\n  }\n\n  /**\n   * Generate random key\n   * @param {number} length - Key length in bytes\n   * @returns {string} Random key\n   */\n  generateKey(length = 32) {\n    return crypto.randomBytes(length).toString('hex');\n  }\n\n  /**\n   * Store key\n   * @param {string} keyId - Key ID\n   * @param {string} key - Key value\n   * @returns {boolean} Success\n   */\n  storeKey(keyId, key) {\n    if (this.keyStore.has(keyId)) {\n      throw new Error(`Key ${keyId} already exists`);\n    }\n    this.keyStore.set(keyId, key);\n    return true;\n  }\n\n  /**\n   * Rotate key\n   * @param {string} keyId - Key ID to rotate\n   * @returns {Object} New key info\n   */\n  rotateKey(keyId) {\n    const oldKey = this.keyStore.get(keyId);\n    if (!oldKey) throw new Error(`Key ${keyId} not found`);\n\n    const newKey = this.generateKey(32);\n    const archivedKeyId = `${keyId}-archived-${Date.now()}`;\n\n    // Archive old key\n    this.keyStore.set(archivedKeyId, oldKey);\n\n    // Store new key\n    this.keyStore.set(keyId, newKey);\n\n    return {\n      keyId,\n      archivedKeyId,\n      rotatedAt: new Date()\n    };\n  }\n\n  /**\n   * Sign data (create signature)\n   * @param {string} data - Data to sign\n   * @param {string} keyId - Private key ID\n   * @returns {string} Signature\n   */\n  sign(data, keyId = 'default') {\n    const key = this.keyStore.get(keyId);\n    if (!key) throw new Error(`Key ${keyId} not found`);\n\n    const hmac = crypto.createHmac('sha256', key);\n    hmac.update(data);\n    return hmac.digest('hex');\n  }\n\n  /**\n   * Verify signature\n   * @param {string} data - Original data\n   * @param {string} signature - Signature to verify\n   * @param {string} keyId - Key ID\n   * @returns {boolean} Verification result\n   */\n  verifySignature(data, signature, keyId = 'default') {\n    const computed = this.sign(data, keyId);\n    return computed === signature;\n  }\n\n  /**\n   * Generate certificate\n   * @param {Object} certData - Certificate data\n   * @returns {Object} Certificate\n   */\n  generateCertificate(certData) {\n    const certId = crypto.randomUUID();\n    const publicKey = this.generateKey(32);\n    const privateKey = this.generateKey(32);\n\n    const certificate = {\n      id: certId,\n      subject: certData.subject,\n      issuer: certData.issuer || 'Self',\n      publicKey,\n      privateKey,\n      validFrom: new Date(),\n      validUntil: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year\n      fingerprint: this.hash(publicKey + privateKey),\n      isActive: true\n    };\n\n    this.keyStore.set(`cert-${certId}`, { publicKey, privateKey });\n\n    return certificate;\n  }\n\n  /**\n   * Encrypt field (for PII)\n   * @param {string} field - Field name\n   * @param {string} value - Field value\n   * @param {string} keyId - Key ID\n   * @returns {Object} Encrypted field\n   */\n  encryptField(field, value, keyId = 'default') {\n    const encrypted = this.encrypt(value, keyId);\n    return {\n      field,\n      encryptedId: encrypted.encryptedId,\n      algorithm: 'aes-256-gcm',\n      encrypted: true\n    };\n  }\n\n  /**\n   * Decrypt field\n   * @param {string} encryptedId - Encrypted ID\n   * @param {string} keyId - Key ID\n   * @returns {string} Decrypted value\n   */\n  decryptField(encryptedId, keyId = 'default') {\n    return this.decrypt(encryptedId, keyId);\n  }\n\n  /**\n   * Initialize default keys\n   * @private\n   */\n  _initializeKeys() {\n    // Generate default encryption key\n    const defaultKey = this.generateKey(32);\n    this.keyStore.set('default', defaultKey);\n\n    // Generate master key (for key encryption)\n    const masterKey = this.generateKey(32);\n    this.keyStore.set('master', masterKey);\n\n    // Generate backup key\n    const backupKey = this.generateKey(32);\n    this.keyStore.set('backup', backupKey);\n  }\n}\n\nmodule.exports = new EncryptionService();\n