/**\n * Report Service - Phase 10 Report Generation & Export\n * Handles report creation, generation, and export functionality\n */\n\nconst crypto = require('crypto');\n\nclass ReportService {\n  constructor() {\n    this.reports = new Map();\n    this.schedules = new Map();\n    this.templates = this._initializeTemplates();\n  }\n\n  /**\n   * Create a new report\n   * @param {string} userId - User ID\n   * @param {Object} reportData - Report configuration\n   * @returns {Object} Created report\n   */\n  createReport(userId, reportData) {\n    const reportId = crypto.randomUUID();\n    const report = {\n      id: reportId,\n      userId,\n      name: reportData.name || 'Untitled Report',\n      type: reportData.type || 'custom', // sales, hr, financial, project, custom\n      description: reportData.description || '',\n      format: reportData.format || 'pdf', // pdf, excel, csv, json\n      filters: reportData.filters || {},\n      columns: reportData.columns || [],\n      sortBy: reportData.sortBy || null,\n      groupBy: reportData.groupBy || null,\n      aggregations: reportData.aggregations || [],\n      isScheduled: reportData.isScheduled || false,\n      scheduleFrequency: reportData.scheduleFrequency || null,\n      recipients: reportData.recipients || [],\n      template: reportData.template || null,\n      generationStatus: 'draft',\n      lastGenerated: null,\n      fileSize: 0,\n      downloadUrl: null,\n      created_at: new Date(),\n      updated_at: new Date()\n    };\n\n    this.reports.set(reportId, report);\n    return report;\n  }\n\n  /**\n   * Get report by ID\n   * @param {string} reportId - Report ID\n   * @returns {Object} Report object\n   */\n  getReport(reportId) {\n    const report = this.reports.get(reportId);\n    if (!report) {\n      throw new Error(`Report ${reportId} not found`);\n    }\n    return report;\n  }\n\n  /**\n   * List reports for user\n   * @param {string} userId - User ID\n   * @param {Object} filters - Filter options\n   * @returns {Array} List of reports\n   */\n  listReports(userId, filters = {}) {\n    const reports = Array.from(this.reports.values()).filter(r => {\n      if (r.userId !== userId) return false;\n      if (filters.type && r.type !== filters.type) return false;\n      if (filters.dateFrom && r.created_at < filters.dateFrom) return false;\n      if (filters.dateTo && r.created_at > filters.dateTo) return false;\n      return true;\n    });\n\n    return reports.sort((a, b) => b.updated_at - a.updated_at);\n  }\n\n  /**\n   * Generate report\n   * @param {string} reportId - Report ID\n   * @param {Object} dataSource - Data to include in report\n   * @returns {Object} Generated report\n   */\n  generateReport(reportId, dataSource) {\n    const report = this.getReport(reportId);\n    const startTime = Date.now();\n\n    try {\n      // Apply filters\n      let filteredData = this._applyFilters(dataSource, report.filters);\n\n      // Apply grouping\n      if (report.groupBy) {\n        filteredData = this._groupData(filteredData, report.groupBy);\n      }\n\n      // Apply aggregations\n      if (report.aggregations.length > 0) {\n        filteredData = this._aggregateData(filteredData, report.aggregations);\n      }\n\n      // Apply sorting\n      if (report.sortBy) {\n        filteredData = this._sortData(filteredData, report.sortBy);\n      }\n\n      // Select columns\n      if (report.columns.length > 0) {\n        filteredData = filteredData.map(item => {\n          const filtered = {};\n          report.columns.forEach(col => {\n            filtered[col] = item[col];\n          });\n          return filtered;\n        });\n      }\n\n      // Generate file based on format\n      const generatedFile = this._generateFile(filteredData, report.format, report.name);\n\n      // Update report\n      report.generationStatus = 'completed';\n      report.lastGenerated = new Date();\n      report.fileSize = generatedFile.size;\n      report.downloadUrl = `/reports/${reportId}/download`;\n      report.updated_at = new Date();\n\n      const generationTime = Date.now() - startTime;\n\n      return {\n        reportId,\n        status: 'success',\n        generatedAt: report.lastGenerated,\n        generationTime,\n        rowCount: filteredData.length,\n        format: report.format,\n        downloadUrl: report.downloadUrl,\n        fileSize: report.fileSize\n      };\n    } catch (error) {\n      report.generationStatus = 'failed';\n      report.updated_at = new Date();\n      throw error;\n    }\n  }\n\n  /**\n   * Schedule recurring report\n   * @param {string} reportId - Report ID\n   * @param {Object} scheduleConfig - Schedule configuration\n   * @returns {Object} Schedule information\n   */\n  scheduleReport(reportId, scheduleConfig) {\n    const report = this.getReport(reportId);\n    const scheduleId = crypto.randomUUID();\n\n    const schedule = {\n      id: scheduleId,\n      reportId,\n      frequency: scheduleConfig.frequency, // daily, weekly, monthly\n      dayOfWeek: scheduleConfig.dayOfWeek || null,\n      dayOfMonth: scheduleConfig.dayOfMonth || null,\n      time: scheduleConfig.time || '09:00',\n      timezone: scheduleConfig.timezone || 'UTC',\n      recipients: scheduleConfig.recipients || [],\n      emailSubject: scheduleConfig.emailSubject || `${report.name} Report`,\n      isActive: true,\n      lastRun: null,\n      nextRun: this._calculateNextRun(scheduleConfig),\n      created_at: new Date()\n    };\n\n    this.schedules.set(scheduleId, schedule);\n    report.isScheduled = true;\n    report.scheduleFrequency = scheduleConfig.frequency;\n\n    return schedule;\n  }\n\n  /**\n   * Update report\n   * @param {string} reportId - Report ID\n   * @param {Object} updates - Update fields\n   * @returns {Object} Updated report\n   */\n  updateReport(reportId, updates) {\n    const report = this.getReport(reportId);\n    \n    Object.assign(report, updates, {\n      updated_at: new Date()\n    });\n\n    return report;\n  }\n\n  /**\n   * Delete report\n   * @param {string} reportId - Report ID\n   * @returns {boolean} Success\n   */\n  deleteReport(reportId) {\n    return this.reports.delete(reportId);\n  }\n\n  /**\n   * Get templates\n   * @returns {Object} Available report templates\n   */\n  getTemplates() {\n    return this.templates;\n  }\n\n  /**\n   * Export report to file\n   * @param {string} reportId - Report ID\n   * @param {string} format - Export format\n   * @returns {Object} Export details\n   */\n  exportReport(reportId, format = null) {\n    const report = this.getReport(reportId);\n    const exportFormat = format || report.format;\n\n    return {\n      reportId,\n      name: `${report.name}.${exportFormat}`,\n      format: exportFormat,\n      size: report.fileSize,\n      generatedAt: report.lastGenerated,\n      downloadUrl: report.downloadUrl\n    };\n  }\n\n  /**\n   * Apply filters to data\n   * @private\n   */\n  _applyFilters(data, filters) {\n    if (!filters || Object.keys(filters).length === 0) return data;\n\n    return data.filter(item => {\n      for (const [key, filterValue] of Object.entries(filters)) {\n        if (Array.isArray(filterValue)) {\n          if (!filterValue.includes(item[key])) return false;\n        } else if (typeof filterValue === 'object') {\n          if (filterValue.min && item[key] < filterValue.min) return false;\n          if (filterValue.max && item[key] > filterValue.max) return false;\n        } else if (item[key] !== filterValue) {\n          return false;\n        }\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Group data\n   * @private\n   */\n  _groupData(data, groupByFields) {\n    const grouped = {};\n\n    data.forEach(item => {\n      const groupKey = groupByFields.map(field => item[field]).join('|');\n      if (!grouped[groupKey]) {\n        grouped[groupKey] = [];\n      }\n      grouped[groupKey].push(item);\n    });\n\n    return Object.values(grouped);\n  }\n\n  /**\n   * Aggregate data\n   * @private\n   */\n  _aggregateData(data, aggregations) {\n    if (!Array.isArray(data[0])) {\n      data = [data];\n    }\n\n    return data.map(group => {\n      const aggregated = { ...group[0] };\n\n      aggregations.forEach(agg => {\n        const values = group.map(item => item[agg.field]);\n        switch (agg.function) {\n          case 'sum':\n            aggregated[agg.alias] = values.reduce((a, b) => a + b, 0);\n            break;\n          case 'avg':\n            aggregated[agg.alias] = values.reduce((a, b) => a + b, 0) / values.length;\n            break;\n          case 'count':\n            aggregated[agg.alias] = values.length;\n            break;\n          case 'max':\n            aggregated[agg.alias] = Math.max(...values);\n            break;\n          case 'min':\n            aggregated[agg.alias] = Math.min(...values);\n            break;\n        }\n      });\n\n      return aggregated;\n    });\n  }\n\n  /**\n   * Sort data\n   * @private\n   */\n  _sortData(data, sortBy) {\n    return [...data].sort((a, b) => {\n      const aVal = a[sortBy.field];\n      const bVal = b[sortBy.field];\n\n      if (aVal < bVal) return sortBy.direction === 'asc' ? -1 : 1;\n      if (aVal > bVal) return sortBy.direction === 'asc' ? 1 : -1;\n      return 0;\n    });\n  }\n\n  /**\n   * Generate file content\n   * @private\n   */\n  _generateFile(data, format, filename) {\n    let content = '';\n    let size = 0;\n\n    switch (format) {\n      case 'csv':\n        content = this._generateCSV(data);\n        break;\n      case 'excel':\n        content = this._generateExcel(data);\n        break;\n      case 'json':\n        content = JSON.stringify(data, null, 2);\n        break;\n      case 'pdf':\n      default:\n        content = this._generatePDF(data, filename);\n    }\n\n    size = Buffer.byteLength(content);\n    return { content, size, filename };\n  }\n\n  /**\n   * Generate CSV\n   * @private\n   */\n  _generateCSV(data) {\n    if (data.length === 0) return '';\n\n    const headers = Object.keys(data[0]);\n    const rows = data.map(item => \n      headers.map(h => `\"${item[h]}\"`).join(',')\n    );\n\n    return [headers.join(','), ...rows].join('\\n');\n  }\n\n  /**\n   * Generate Excel (mock)\n   * @private\n   */\n  _generateExcel(data) {\n    return this._generateCSV(data); // Mock - would use xlsx library in production\n  }\n\n  /**\n   * Generate PDF (mock)\n   * @private\n   */\n  _generatePDF(data, filename) {\n    return `PDF Report: ${filename}\\n${JSON.stringify(data)}`.repeat(100);\n  }\n\n  /**\n   * Initialize report templates\n   * @private\n   */\n  _initializeTemplates() {\n    return {\n      salesSummary: {\n        name: 'Sales Summary',\n        type: 'sales',\n        columns: ['date', 'product', 'quantity', 'revenue', 'margin'],\n        aggregations: ['sum:quantity', 'sum:revenue']\n      },\n      hrReport: {\n        name: 'HR Report',\n        type: 'hr',\n        columns: ['employee', 'department', 'salary', 'attendance', 'performance'],\n        groupBy: ['department']\n      },\n      financialSummary: {\n        name: 'Financial Summary',\n        type: 'financial',\n        columns: ['account', 'amount', 'category', 'date'],\n        aggregations: ['sum:amount']\n      }\n    };\n  }\n\n  /**\n   * Calculate next run time for schedule\n   * @private\n   */\n  _calculateNextRun(scheduleConfig) {\n    const now = new Date();\n    const next = new Date(now);\n\n    switch (scheduleConfig.frequency) {\n      case 'daily':\n        next.setDate(next.getDate() + 1);\n        break;\n      case 'weekly':\n        next.setDate(next.getDate() + 7);\n        break;\n      case 'monthly':\n        next.setMonth(next.getMonth() + 1);\n        break;\n    }\n\n    return next;\n  }\n}\n\nmodule.exports = new ReportService();\n