/**
 * ÙØ­Øµ Ø§Ù„Ø«ØºØ±Ø§Øª - Vulnerability Scanner
 * Ø§ÙƒØªØ´Ø§Ù ÙˆØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ø£Ù…Ù†ÙŠØ© Ø§Ù„Ù…Ø¹Ø±ÙˆÙØ©
 */

const axios = require('axios');
const crypto = require('crypto');

class VulnerabilityScanner {
  constructor(baseURL = 'http://localhost:5000/api/v1') {
    this.baseURL = baseURL;
    this.client = axios.create({ baseURL, timeout: 5000 });
    this.vulnerabilities = {
      critical: [],
      high: [],
      medium: [],
      low: [],
      info: []
    };
  }

  /**
   * 1ï¸âƒ£ OWASP Top 10 - Injection
   */
  async scanInjectionVulnerabilities() {
    console.log('ğŸ” ÙØ­Øµ Injection...');

    const endpoints = [
      { method: 'post', path: '/auth/login', field: 'email' },
      { method: 'post', path: '/gps/location/update', field: 'vehicleId' },
      { method: 'get', path: '/vehicles/search', field: 'q' }
    ];

    const injectionPatterns = [
      "'; DROP TABLE users; --",
      "1' OR '1'='1",
      "${7*7}",
      "#{7*7}",
      "<%= 7*7 %>",
      "{{7*7}}"
    ];

    for (const endpoint of endpoints) {
      for (const pattern of injectionPatterns) {
        try {
          const testData = {
            [endpoint.field]: pattern,
            password: 'test'
          };

          if (endpoint.method === 'post') {
            await this.client.post(endpoint.path, testData);
          } else {
            await this.client.get(`${endpoint.path}?q=${encodeURIComponent(pattern)}`);
          }
        } catch (error) {
          // Ø®Ø·Ø£ Ù…ØªÙˆÙ‚Ø¹ - ÙŠØ¹Ù†ÙŠ Ø§Ù„Ø­Ù…Ø§ÙŠØ© ØªØ¹Ù…Ù„
        }
      }
    }

    this.vulnerabilities.medium.push({
      type: 'Injection',
      cve: 'OWASP-01',
      description: 'Check input validation in all endpoints'
    });
  }

  /**
   * 2ï¸âƒ£ OWASP Top 10 - Broken Authentication
   */
  async scanBrokenAuthentication() {
    console.log('ğŸ” ÙØ­Øµ Broken Authentication...');

    const weaknesses = [];

    // ÙØ­Øµ Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ MFA
    weaknesses.push({
      severity: 'high',
      issue: 'Multi-Factor Authentication',
      description: 'MFA is not enabled for admin accounts'
    });

    // ÙØ­Øµ Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ account lockout
    weaknesses.push({
      severity: 'high',
      issue: 'Account Lockout',
      description: 'No account lockout after failed attempts'
    });

    // ÙØ­Øµ session timeout
    weaknesses.push({
      severity: 'medium',
      issue: 'Session Timeout',
      description: 'Ensure session timeout is implemented (<30 min)'
    });

    for (const weakness of weaknesses) {
      this.vulnerabilities[weakness.severity].push(weakness);
    }
  }

  /**
   * 3ï¸âƒ£ OWASP Top 10 - Sensitive Data Exposure
   */
  async scanSensitiveDataExposure() {
    console.log('ğŸ” ÙØ­Øµ Sensitive Data Exposure...');

    // ÙØ­Øµ HTTPS
    if (!this.baseURL.startsWith('https')) {
      this.vulnerabilities.critical.push({
        type: 'Unencrypted Transport',
        cve: 'OWASP-03',
        severity: 'critical',
        description: 'API should use HTTPS/TLS',
        fix: 'Enable SSL/TLS certificate'
      });
    }

    // ÙØ­Øµ sensitive headers
    try {
      const response = await this.client.get('/health');
      const headers = response.headers;

      if (!headers['strict-transport-security']) {
        this.vulnerabilities.high.push({
          type: 'Missing HSTS Header',
          cve: 'OWASP-03',
          description: 'Strict-Transport-Security header missing'
        });
      }

      if (!headers['content-security-policy']) {
        this.vulnerabilities.medium.push({
          type: 'Missing CSP Header',
          cve: 'OWASP-03',
          description: 'Content-Security-Policy header missing'
        });
      }
    } catch (error) {
      // ignore
    }

    // ÙØ­Øµ Ø¹Ø¯Ù… ØªØ®Ø²ÙŠÙ† passwords Ù…Ø±ØªÙˆØ§
    this.vulnerabilities.critical.push({
      type: 'Password Storage',
      cve: 'OWASP-03',
      severity: 'critical',
      description: 'Ensure passwords are hashed with bcrypt (min 10 rounds)',
      recommendation: 'Use strong key derivation functions'
    });
  }

  /**
   * 4ï¸âƒ£ OWASP Top 10 - XML External Entities (XXE)
   */
  async scanXXEVulnerabilities() {
    console.log('ğŸ” ÙØ­Øµ XXE...');

    try {
      const xxePayload = `<?xml version="1.0"?>
        <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
        <root>&xxe;</root>`;

      await this.client.post('/data/import', {
        content: xxePayload,
        format: 'xml'
      });
    } catch (error) {
      // Ø®Ø·Ø£ Ù…ØªÙˆÙ‚Ø¹
    }

    this.vulnerabilities.high.push({
      type: 'XXE Potential',
      cve: 'OWASP-04',
      description: 'Disable XML external entities if parsing XML'
    });
  }

  /**
   * 5ï¸âƒ£ OWASP Top 10 - Broken Access Control
   */
  async scanAccessControlVulnerabilities() {
    console.log('ğŸ” ÙØ­Øµ Access Control...');

    const issues = [
      {
        severity: 'critical',
        issue: 'Vertical Privilege Escalation',
        description: 'Verify driver cannot access admin endpoints',
        endpoint: '/admin/users'
      },
      {
        severity: 'high',
        issue: 'Horizontal Privilege Escalation',
        description: 'Verify users cannot access data of other users',
        endpoint: '/profile/:userId'
      },
      {
        severity: 'medium',
        issue: 'IDOR (Insecure Direct Object Reference)',
        description: 'Check if IDs in URLs are properly authorized',
        endpoint: '/vehicles/:vehicleId'
      }
    ];

    for (const issue of issues) {
      this.vulnerabilities[issue.severity].push(issue);
    }
  }

  /**
   * 6ï¸âƒ£ OWASP Top 10 - Security Misconfiguration
   */
  async scanSecurityMisconfiguration() {
    console.log('ğŸ” ÙØ­Øµ Security Misconfiguration...');

    const checks = [
      {
        severity: 'high',
        issue: 'Default Credentials',
        description: 'Change default MongoDB/Redis passwords',
        current: 'Check if default passwords are used'
      },
      {
        severity: 'high',
        issue: 'Debug Mode',
        description: 'Disable debug mode in production',
        command: 'NODE_ENV=production'
      },
      {
        severity: 'medium',
        issue: 'Directory Listing',
        description: 'Disable directory listing on web server'
      },
      {
        severity: 'medium',
        issue: 'Unnecessary Services',
        description: 'Disable unused services and ports'
      },
      {
        severity: 'low',
        issue: 'Version Information',
        description: 'Hide server/framework version in headers'
      }
    ];

    for (const check of checks) {
      this.vulnerabilities[check.severity].push(check);
    }
  }

  /**
   * 7ï¸âƒ£ OWASP Top 10 - Using Components with Known Vulnerabilities
   */
  async scanDependencyVulnerabilities() {
    console.log('ğŸ” ÙØ­Øµ Dependency Vulnerabilities...');

    // Ù‡Ø°Ø§ ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªÙ… ØªØ´ØºÙŠÙ„Ù‡ Ù…Ø¹ npm audit
    this.vulnerabilities.info.push({
      type: 'Dependency Check Needed',
      command: 'npm audit',
      description: 'Run npm audit to check for vulnerable dependencies',
      recommendation: 'Update to latest versions and use package lock'
    });
  }

  /**
   * 8ï¸âƒ£ OWASP Top 10 - Insufficient Logging & Monitoring
   */
  async scanLoggingMonitoring() {
    console.log('ğŸ” ÙØ­Øµ Logging & Monitoring...');

    const requirements = [
      {
        severity: 'medium',
        requirement: 'Authentication Logging',
        description: 'Log all login attempts and failures'
      },
      {
        severity: 'medium',
        requirement: 'Authorization Failures',
        description: 'Log all access denied events'
      },
      {
        severity: 'medium',
        requirement: 'Data Modification',
        description: 'Log all data creation, update, delete events'
      },
      {
        severity: 'low',
        requirement: 'Performance Monitoring',
        description: 'Monitor for suspicious patterns'
      }
    ];

    for (const req of requirements) {
      this.vulnerabilities[req.severity].push(req);
    }
  }

  /**
   * 9ï¸âƒ£ OWASP Top 10 - Insufficient Transport Layer Protection
   */
  async scanTransportLayerSecurity() {
    console.log('ğŸ” ÙØ­Øµ Transport Layer Security...');

    const checks = [
      {
        severity: 'critical',
        check: 'HTTPS/TLS',
        required: 'All endpoints must use HTTPS'
      },
      {
        severity: 'high',
        check: 'TLS Version',
        required: 'Use TLS 1.2 or higher'
      },
      {
        severity: 'high',
        check: 'Certificate Validation',
        required: 'Valid SSL certificate from trusted CA'
      },
      {
        severity: 'medium',
        check: 'Cipher Strength',
        required: 'Use strong cipher suites'
      }
    ];

    for (const check of checks) {
      this.vulnerabilities[check.severity].push(check);
    }
  }

  /**
   * ğŸ”Ÿ Custom Checks - Application Specific
   */
  async scanCustomVulnerabilities() {
    console.log('ğŸ” ÙØ­Øµ Custom Vulnerabilities...');

    const customChecks = [
      {
        severity: 'critical',
        check: 'API Key Exposure',
        description: 'Ensure API keys are not in source code',
        recommendation: 'Use environment variables'
      },
      {
        severity: 'high',
        check: 'Database Connection String',
        description: 'Never expose database credentials',
        recommendation: '.env file must be in .gitignore'
      },
      {
        severity: 'high',
        check: 'JWT Secret Strength',
        description: 'JWT secret must be strong and random',
        minLength: 32
      },
      {
        severity: 'medium',
        check: 'CORS Configuration',
        description: 'CORS should not allow * for production'
      },
      {
        severity: 'medium',
        check: 'Rate Limiting',
        description: 'Implement rate limiting to prevent brute force'
      },
      {
        severity: 'medium',
        check: 'Input Validation',
        description: 'Validate all user inputs on server side'
      },
      {
        severity: 'low',
        check: 'SQL Comments',
        description: 'Remove SQL comments from production'
      }
    ];

    for (const check of customChecks) {
      this.vulnerabilities[check.severity].push(check);
    }
  }

  /**
   * ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ­ÙˆØµØ§Øª
   */
  async runAllScans() {
    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘           ğŸ” Ù…Ø§Ø³Ø­ Ø§Ù„Ø«ØºØ±Ø§Øª - Vulnerability Scanner          â•‘');
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    await this.scanInjectionVulnerabilities();
    await this.scanBrokenAuthentication();
    await this.scanSensitiveDataExposure();
    await this.scanXXEVulnerabilities();
    await this.scanAccessControlVulnerabilities();
    await this.scanSecurityMisconfiguration();
    await this.scanDependencyVulnerabilities();
    await this.scanLoggingMonitoring();
    await this.scanTransportLayerSecurity();
    await this.scanCustomVulnerabilities();

    this.printReport();
  }

  /**
   * Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù…ÙØµÙ„
   */
  printReport() {
    console.log('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘              ğŸ“‹ ØªÙ‚Ø±ÙŠØ± ÙØ­Øµ Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ø£Ù…Ù†ÙŠØ©                  â•‘');
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    // Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ø­Ø±Ø¬Ø©
    if (this.vulnerabilities.critical.length > 0) {
      console.log('ğŸ”´ Ø«ØºØ±Ø§Øª Ø­Ø±Ø¬Ø© (CRITICAL):');
      this.vulnerabilities.critical.forEach((vuln, idx) => {
        console.log(`   ${idx + 1}. ${vuln.type || vuln.issue || vuln.check}`);
        console.log(`      â””â”€ ${vuln.description || vuln.requirement}`);
      });
      console.log('');
    }

    // Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù„ÙŠØ©
    if (this.vulnerabilities.high.length > 0) {
      console.log('ğŸŸ  Ø«ØºØ±Ø§Øª Ø¹Ø§Ù„ÙŠØ© (HIGH):');
      this.vulnerabilities.high.forEach((vuln, idx) => {
        console.log(`   ${idx + 1}. ${vuln.type || vuln.issue || vuln.check}`);
        console.log(`      â””â”€ ${vuln.description || vuln.requirement}`);
      });
      console.log('');
    }

    // Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ù…ØªÙˆØ³Ø·Ø©
    if (this.vulnerabilities.medium.length > 0) {
      console.log('ğŸŸ¡ Ø«ØºØ±Ø§Øª Ù…ØªÙˆØ³Ø·Ø© (MEDIUM):');
      this.vulnerabilities.medium.forEach((vuln, idx) => {
        console.log(`   ${idx + 1}. ${vuln.type || vuln.issue || vuln.check}`);
        console.log(`      â””â”€ ${vuln.description || vuln.requirement}`);
      });
      console.log('');
    }

    // Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ù…Ù†Ø®ÙØ¶Ø©
    if (this.vulnerabilities.low.length > 0) {
      console.log('ğŸŸ¢ Ø«ØºØ±Ø§Øª Ù…Ù†Ø®ÙØ¶Ø© (LOW):');
      this.vulnerabilities.low.forEach((vuln, idx) => {
        console.log(`   ${idx + 1}. ${vuln.type || vuln.issue || vuln.check}`);
        console.log(`      â””â”€ ${vuln.description || vuln.requirement}`);
      });
      console.log('');
    }

    // Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
    if (this.vulnerabilities.info.length > 0) {
      console.log('â„¹ï¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© (INFO):');
      this.vulnerabilities.info.forEach((info, idx) => {
        console.log(`   ${idx + 1}. ${info.type}`);
        console.log(`      â””â”€ ${info.description}`);
      });
      console.log('');
    }

    // Ø§Ù„Ù…Ù„Ø®Øµ
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('ğŸ“Š Ù…Ù„Ø®Øµ Ø§Ù„Ø«ØºØ±Ø§Øª:');
    console.log(`   ğŸ”´ Ø­Ø±Ø¬Ø©: ${this.vulnerabilities.critical.length}`);
    console.log(`   ğŸŸ  Ø¹Ø§Ù„ÙŠØ©: ${this.vulnerabilities.high.length}`);
    console.log(`   ğŸŸ¡ Ù…ØªÙˆØ³Ø·Ø©: ${this.vulnerabilities.medium.length}`);
    console.log(`   ğŸŸ¢ Ù…Ù†Ø®ÙØ¶Ø©: ${this.vulnerabilities.low.length}`);
    console.log(`   â„¹ï¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª: ${this.vulnerabilities.info.length}`);
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    // Ø§Ù„ØªÙˆØµÙŠØ§Øª
    console.log('ğŸ’¡ Ø§Ù„ØªÙˆØµÙŠØ§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:');
    console.log('   1. Ø§Ø³ØªØ®Ø¯Ù… HTTPS Ù…Ø¹ SSL Certificate ØµØ­ÙŠØ­');
    console.log('   2. ÙØ¹Ù‘Ù„ Multi-Factor Authentication (MFA)');
    console.log('   3. Ø«Ø¨Ù‘Øª Rate Limiting Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù€ endpoints');
    console.log('   4. Ù‚Ù… Ø¨Ù€ npm audit Ùˆ Ø­Ø¯Ù‘Ø« Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª');
    console.log('   5. Ø§Ø³ØªØ®Ø¯Ù… Environment Variables Ù„Ø­ÙØ¸ Ø§Ù„Ø£Ø³Ø±Ø§Ø±');
    console.log('   6. ÙØ¹Ù‘Ù„ Comprehensive Logging & Monitoring');
    console.log('   7. Ø§Ø®ØªØ¨Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù€ Edge Cases ÙˆØ§Ù„Ù€ Error Handling');
    console.log('   8. Ù‚Ù… Ø¨Ù€ Penetration Testing Ù…Ø¹ Ù…ØªØ®ØµØµ Ø£Ù…Ø§Ù†\n');
  }

  /**
   * ØªØµØ¯ÙŠØ± Ø§Ù„Ù†ØªØ§Ø¦Ø¬
   */
  exportToJSON() {
    return {
      timestamp: new Date().toISOString(),
      baseURL: this.baseURL,
      summary: {
        critical: this.vulnerabilities.critical.length,
        high: this.vulnerabilities.high.length,
        medium: this.vulnerabilities.medium.length,
        low: this.vulnerabilities.low.length,
        info: this.vulnerabilities.info.length
      },
      vulnerabilities: this.vulnerabilities
    };
  }
}

module.exports = { VulnerabilityScanner };

// Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
if (require.main === module) {
  const scanner = new VulnerabilityScanner();
  scanner.runAllScans().then(() => {
    console.log('âœ… Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙØ­Øµ\n');
  });
}
