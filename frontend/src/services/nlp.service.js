'use strict';\n\n/**\n * ðŸ—£ï¸ Natural Language Processing Service\n * \n * Processes and analyzes natural language:\n * - Text analysis\n * - Sentiment analysis\n * - Keyword extraction\n * - Text classification\n * - Intent recognition\n * \n * @module nlp.service\n * @version 1.0.0\n */\n\nclass NLPService {\n  constructor() {\n    this.name = 'NLPService';\n    this.version = '1.0.0';\n    this.vocabulary = new Map();\n    this.models = {};\n    this.cache = new Map();\n    this.initialized = false;\n\n    // Common stop words\n    this.stopWords = new Set([\n      'the', 'a', 'an', 'and', 'or', 'but', 'is', 'was', 'are', 'were',\n      'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did',\n      'will', 'would', 'could', 'should', 'may', 'might', 'can', 'to',\n      'in', 'on', 'at', 'by', 'from', 'with', 'for', 'of', 'about'\n    ]);\n\n    // Sentiment words\n    this.positiveWords = new Set([\n      'good', 'great', 'excellent', 'amazing', 'wonderful', 'fantastic',\n      'positive', 'happy', 'love', 'perfect', 'best', 'awesome', 'brilliant'\n    ]);\n\n    this.negativeWords = new Set([\n      'bad', 'terrible', 'awful', 'horrible', 'negative', 'sad', 'hate',\n      'worst', 'poor', 'fail', 'failure', 'wrong', 'broken', 'issue'\n    ]);\n\n    this.init();\n  }\n\n  /**\n   * Initialize service\n   */\n  init() {\n    try {\n      const saved = localStorage.getItem('nlp-data');\n      if (saved) {\n        const data = JSON.parse(saved);\n        this.vocabulary = new Map(data.vocabulary || []);\n        this.models = data.models || {};\n      }\n\n      this.initialized = true;\n      this.log('âœ… NLP Service initialized');\n    } catch (error) {\n      this.error('Initialization failed:', error);\n    }\n  }\n\n  /**\n   * Analyze text\n   * @param {String} text - Text to analyze\n   * @returns {Object} Analysis results\n   */\n  analyzeText(text) {\n    if (!text || typeof text !== 'string') {\n      return { error: 'Invalid text input' };\n    }\n\n    const cacheKey = `analysis-${text.slice(0, 50)}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey);\n    }\n\n    const result = {\n      original: text,\n      length: text.length,\n      wordCount: text.split(/\\s+/).length,\n      sentences: this.splitSentences(text),\n      tokens: this.tokenize(text),\n      sentiment: this.analyzeSentiment(text),\n      keywords: this.extractKeywords(text),\n      language: this.detectLanguage(text)\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  /**\n   * Analyze sentiment\n   * @param {String} text - Text to analyze\n   * @returns {Object} Sentiment analysis\n   */\n  analyzeSentiment(text) {\n    const words = this.tokenize(text);\n    let positiveCount = 0;\n    let negativeCount = 0;\n\n    words.forEach(word => {\n      const lower = word.toLowerCase();\n      if (this.positiveWords.has(lower)) positiveCount++;\n      if (this.negativeWords.has(lower)) negativeCount++;\n    });\n\n    const total = positiveCount + negativeCount;\n    let sentiment = 'neutral';\n    let score = 0;\n\n    if (total > 0) {\n      score = (positiveCount - negativeCount) / total;\n      sentiment = score > 0.1 ? 'positive' : score < -0.1 ? 'negative' : 'neutral';\n    }\n\n    return {\n      sentiment,\n      score: score.toFixed(2),\n      positiveWords: positiveCount,\n      negativeWords: negativeCount,\n      confidence: Math.min((total / Math.max(words.length, 1)) * 100, 100).toFixed(2) + '%'\n    };\n  }\n\n  /**\n   * Extract keywords\n   * @param {String} text - Text to analyze\n   * @returns {Array} Keywords\n   */\n  extractKeywords(text) {\n    const tokens = this.tokenize(text);\n    const frequencyMap = {};\n\n    // Count word frequencies\n    tokens.forEach(token => {\n      if (!this.stopWords.has(token.toLowerCase())) {\n        const lower = token.toLowerCase();\n        frequencyMap[lower] = (frequencyMap[lower] || 0) + 1;\n      }\n    });\n\n    // Get top keywords\n    return Object.entries(frequencyMap)\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 10)\n      .map(([keyword, frequency]) => ({\n        keyword,\n        frequency,\n        relevance: ((frequency / tokens.length) * 100).toFixed(2) + '%'\n      }));\n  }\n\n  /**\n   * Classify text\n   * @param {String} text - Text to classify\n   * @param {Array} categories - Categories to classify into\n   * @returns {Object} Classification\n   */\n  classifyText(text, categories = ['positive', 'negative', 'neutral']) {\n    const sentiment = this.analyzeSentiment(text);\n    const keywords = this.extractKeywords(text);\n\n    // Map sentiment to category\n    let classification = 'neutral';\n    if (sentiment.sentiment === 'positive') {\n      classification = 'positive';\n    } else if (sentiment.sentiment === 'negative') {\n      classification = 'negative';\n    }\n\n    // Check if category is in provided list\n    if (!categories.includes(classification)) {\n      classification = categories[0];\n    }\n\n    return {\n      text: text.slice(0, 100),\n      classification,\n      confidence: sentiment.confidence,\n      keywords: keywords.slice(0, 5).map(k => k.keyword),\n      allCategories: categories\n    };\n  }\n\n  /**\n   * Recognize intent\n   * @param {String} text - User input\n   * @returns {Object} Intent recognition\n   */\n  recognizeIntent(text) {\n    const lower = text.toLowerCase();\n    const intents = [];\n\n    // Check for common intents\n    if (/^(what|when|where|who|why|how)/i.test(text)) {\n      intents.push({ intent: 'question', confidence: 95 });\n    }\n\n    if (/please|thanks|thank you/i.test(text)) {\n      intents.push({ intent: 'polite', confidence: 90 });\n    }\n\n    if (/^(create|add|insert|new)/i.test(text)) {\n      intents.push({ intent: 'create', confidence: 88 });\n    }\n\n    if (/^(delete|remove|drop)/i.test(text)) {\n      intents.push({ intent: 'delete', confidence: 88 });\n    }\n\n    if (/^(update|edit|modify|change)/i.test(text)) {\n      intents.push({ intent: 'update', confidence: 88 });\n    }\n\n    if (/^(get|show|list|display|view)/i.test(text)) {\n      intents.push({ intent: 'retrieve', confidence: 88 });\n    }\n\n    if (/^(help|assistance|support)/i.test(text)) {\n      intents.push({ intent: 'help', confidence: 90 });\n    }\n\n    if (intents.length === 0) {\n      intents.push({ intent: 'unknown', confidence: 50 });\n    }\n\n    return {\n      input: text,\n      intents: intents.sort((a, b) => b.confidence - a.confidence),\n      primaryIntent: intents[0].intent\n    };\n  }\n\n  /**\n   * Tokenize text\n   * @private\n   */\n  tokenize(text) {\n    return text\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter(token => token.length > 0);\n  }\n\n  /**\n   * Split into sentences\n   * @private\n   */\n  splitSentences(text) {\n    return text\n      .split(/[.!?]+/)\n      .map(s => s.trim())\n      .filter(s => s.length > 0);\n  }\n\n  /**\n   * Detect language\n   * @private\n   */\n  detectLanguage(text) {\n    // Simple language detection based on script\n    const arabicRegex = /[\\u0600-\\u06FF]/;\n    const chinaneseRegex = /[\\u4E00-\\u9FFF]/;\n    const cyrillicRegex = /[\\u0400-\\u04FF]/;\n\n    if (arabicRegex.test(text)) return 'ar';\n    if (chinaneseRegex.test(text)) return 'zh';\n    if (cyrillicRegex.test(text)) return 'ru';\n    \n    return 'en'; // Default to English\n  }\n\n  /**\n   * Extract entities\n   * @param {String} text - Text to analyze\n   * @returns {Object} Extracted entities\n   */\n  extractEntities(text) {\n    const entities = {\n      email: [],\n      url: [],\n      phone: [],\n      date: [],\n      amount: []\n    };\n\n    // Email regex\n    const emailRegex = /[\\w.-]+@[\\w.-]+\\.\\w+/g;\n    entities.email = text.match(emailRegex) || [];\n\n    // URL regex\n    const urlRegex = /(https?:\\/\\/[^\\s]+)/g;\n    entities.url = text.match(urlRegex) || [];\n\n    // Phone regex\n    const phoneRegex = /\\(?\\d{3}\\)?[-.]?\\d{3}[-.]?\\d{4}/g;\n    entities.phone = text.match(phoneRegex) || [];\n\n    // Date patterns\n    const dateRegex = /\\d{1,2}[-\\/]\\d{1,2}[-\\/]\\d{2,4}/g;\n    entities.date = text.match(dateRegex) || [];\n\n    // Amount patterns\n    const amountRegex = /[$â‚¬Â£]?\\d+([.,]\\d{2})?/g;\n    entities.amount = text.match(amountRegex) || [];\n\n    return entities;\n  }\n\n  /**\n   * Calculate text similarity\n   * @param {String} text1 - First text\n   * @param {String} text2 - Second text\n   * @returns {Number} Similarity score (0-1)\n   */\n  similarity(text1, text2) {\n    const tokens1 = new Set(this.tokenize(text1));\n    const tokens2 = new Set(this.tokenize(text2));\n\n    const intersection = new Set([...tokens1].filter(t => tokens2.has(t)));\n    const union = new Set([...tokens1, ...tokens2]);\n\n    return (intersection.size / union.size).toFixed(3);\n  }\n\n  /**\n   * Get text statistics\n   * @param {String} text - Text to analyze\n   * @returns {Object} Statistics\n   */\n  getStatistics(text) {\n    const tokens = this.tokenize(text);\n    const sentences = this.splitSentences(text);\n\n    return {\n      characters: text.length,\n      words: tokens.length,\n      sentences: sentences.length,\n      averageWordLength: (text.length / tokens.length).toFixed(2),\n      averageWordsPerSentence: (tokens.length / sentences.length).toFixed(2),\n      readingTime: Math.ceil(tokens.length / 200) + ' min',\n      uniqueWords: new Set(tokens).size\n    };\n  }\n\n  /**\n   * Save service data\n   * @private\n   */\n  save() {\n    try {\n      const data = {\n        vocabulary: Array.from(this.vocabulary.entries()),\n        models: this.models\n      };\n      localStorage.setItem('nlp-data', JSON.stringify(data));\n    } catch (error) {\n      this.error('Failed to save:', error);\n    }\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache() {\n    this.cache.clear();\n    return { message: 'Cache cleared' };\n  }\n\n  /**\n   * Get service status\n   */\n  getStatus() {\n    return {\n      service: this.name,\n      version: this.version,\n      initialized: this.initialized,\n      vocabularySize: this.vocabulary.size,\n      stopWordsCount: this.stopWords.size,\n      cacheSize: this.cache.size,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  // ===== Logging =====\n  log(...args) {\n    console.log(`[${this.name}]`, ...args);\n  }\n\n  error(...args) {\n    console.error(`[${this.name}]`, ...args);\n  }\n}\n\n// Create singleton instance\nif (!window.nlpService) {\n  window.nlpService = new NLPService();\n}\n\n// Export for module environments\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = NLPService;\n}\n"