import * as PDFDocument from 'pdfkit';
import * as ExcelJS from 'exceljs';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Report Generator Service
 * Generate reports in multiple formats (PDF, Excel, CSV)
 */

interface ReportConfig {
  title: string;
  author?: string;
  subject?: string;
  keywords?: string[];
  outputPath?: string;
}

interface ReportData {
  headers: string[];
  rows: any[][];
  charts?: Array<{
    type: 'bar' | 'line' | 'pie';
    data: any;
    title: string;
  }>;
  summary?: Record<string, any>;
}

export class ReportGenerator {
  private config: ReportConfig;
  private outputDir: string;

  constructor(config: ReportConfig) {
    this.config = {
      author: 'System AI',
      outputPath: './reports',
      ...config,
    };

    this.outputDir = this.config.outputPath || './reports';
    this.ensureOutputDirectory();
  }

  /**
   * Ensure Output Directory Exists
   */
  private ensureOutputDirectory(): void {
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
      console.log(`✓ Reports directory created: ${this.outputDir}`);
    }
  }

  /**
   * Generate PDF Report
   */
  async generatePDF(data: ReportData): Promise<string> {
    return new Promise((resolve, reject) => {
      const filename = `${this.sanitizeFilename(this.config.title)}_${Date.now()}.pdf`;
      const filepath = path.join(this.outputDir, filename);

      // @ts-ignore - PDFDocument has complex type definitions
      const doc = new PDFDocument({
        size: 'A4',
        margin: 50,
      });

      const stream = fs.createWriteStream(filepath);

      doc.pipe(stream);

      // Header
      doc.fontSize(20).text(this.config.title, { align: 'center' });
      doc.moveDown();

      if (this.config.author) {
        doc.fontSize(12).text(`Author: ${this.config.author}`, { align: 'center' });
      }

      doc.fontSize(10).text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' });
      doc.moveDown(2);

      // Summary
      if (data.summary) {
        doc.fontSize(14).text('Summary', { underline: true });
        doc.moveDown(0.5);

        for (const [key, value] of Object.entries(data.summary)) {
          doc.fontSize(10).text(`${key}: ${value}`);
        }

        doc.moveDown(2);
      }

      // Table
      if (data.headers && data.rows) {
        doc.fontSize(14).text('Data Table', { underline: true });
        doc.moveDown(0.5);

        // Headers
        doc.fontSize(9).font('Helvetica-Bold');
        const headerText = data.headers.join(' | ');
        doc.text(headerText);
        doc.moveDown(0.3);

        // Rows
        doc.font('Helvetica');
        data.rows.forEach((row, idx) => {
          const rowText = row.join(' | ');
          doc.text(rowText);

          if (idx % 5 === 4) {
            doc.moveDown(0.2);
          }
        });
      }

      // Footer
      doc.moveDown(2);
      doc.fontSize(8).text('Generated by Intelligent Agent System', {
        align: 'center',
      });

      doc.end();

      stream.on('finish', () => {
        console.log(`✓ PDF report generated: ${filepath}`);
        resolve(filepath);
      });

      stream.on('error', reject);
    });
  }

  /**
   * Generate Excel Report
   */
  async generateExcel(data: ReportData): Promise<string> {
    const filename = `${this.sanitizeFilename(this.config.title)}_${Date.now()}.xlsx`;
    const filepath = path.join(this.outputDir, filename);

    const workbook = new ExcelJS.Workbook();
    workbook.creator = this.config.author || 'System AI';
    workbook.created = new Date();
    workbook.modified = new Date();

    const worksheet = workbook.addWorksheet(this.config.title.substring(0, 31));

    // Title
    worksheet.mergeCells('A1:' + this.getColumnLetter(data.headers.length) + '1');
    const titleCell = worksheet.getCell('A1');
    titleCell.value = this.config.title;
    titleCell.font = { size: 16, bold: true };
    titleCell.alignment = { horizontal: 'center', vertical: 'middle' };

    // Metadata
    worksheet.mergeCells('A2:' + this.getColumnLetter(data.headers.length) + '2');
    const metaCell = worksheet.getCell('A2');
    metaCell.value = `Generated: ${new Date().toLocaleString()}`;
    metaCell.font = { size: 10 };
    metaCell.alignment = { horizontal: 'center' };

    worksheet.addRow([]);

    // Summary
    if (data.summary) {
      worksheet.addRow(['Summary']).font = { bold: true, size: 12 };
      for (const [key, value] of Object.entries(data.summary)) {
        worksheet.addRow([key, value]);
      }
      worksheet.addRow([]);
    }

    // Headers
    const headerRow = worksheet.addRow(data.headers);
    headerRow.font = { bold: true };
    headerRow.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF4472C4' },
    };
    headerRow.font = { color: { argb: 'FFFFFFFF' }, bold: true };

    // Data Rows
    data.rows.forEach(row => {
      worksheet.addRow(row);
    });

    // Auto-fit columns
    worksheet.columns.forEach(column => {
      let maxLength = 0;
      column.eachCell?.({ includeEmpty: true }, cell => {
        const length = cell.value ? cell.value.toString().length : 10;
        if (length > maxLength) {
          maxLength = length;
        }
      });
      column.width = Math.min(maxLength + 2, 50);
    });

    await workbook.xlsx.writeFile(filepath);

    console.log(`✓ Excel report generated: ${filepath}`);
    return filepath;
  }

  /**
   * Generate CSV Report
   */
  async generateCSV(data: ReportData): Promise<string> {
    const filename = `${this.sanitizeFilename(this.config.title)}_${Date.now()}.csv`;
    const filepath = path.join(this.outputDir, filename);

    let csv = '';

    // Headers
    csv += data.headers.map(h => `"${h}"`).join(',') + '\n';

    // Rows
    data.rows.forEach(row => {
      csv += row.map(cell => `"${cell}"`).join(',') + '\n';
    });

    fs.writeFileSync(filepath, csv, 'utf-8');

    console.log(`✓ CSV report generated: ${filepath}`);
    return filepath;
  }

  /**
   * Generate Report in All Formats
   */
  async generateAll(data: ReportData): Promise<{ pdf: string; excel: string; csv: string }> {
    const [pdf, excel, csv] = await Promise.all([
      this.generatePDF(data),
      this.generateExcel(data),
      this.generateCSV(data),
    ]);

    return { pdf, excel, csv };
  }

  /**
   * Generate Process Report
   */
  async generateProcessReport(processes: any[]): Promise<string> {
    const headers = ['Process Name', 'Status', 'Duration', 'Steps', 'Created At'];
    const rows = processes.map(p => [
      p.name,
      p.status,
      `${p.duration}s`,
      p.steps?.length || 0,
      new Date(p.createdAt).toLocaleDateString(),
    ]);

    const summary = {
      'Total Processes': processes.length,
      'Completed': processes.filter((p: any) => p.status === 'completed').length,
      'In Progress': processes.filter((p: any) => p.status === 'in-progress').length,
      'Average Duration': `${(processes.reduce((sum: number, p: any) => sum + (p.duration || 0), 0) / processes.length).toFixed(2)}s`,
    };

    return this.generatePDF({ headers, rows, summary });
  }

  /**
   * Get Column Letter for Excel
   */
  private getColumnLetter(columnNumber: number): string {
    let letter = '';
    while (columnNumber > 0) {
      const remainder = (columnNumber - 1) % 26;
      letter = String.fromCharCode(65 + remainder) + letter;
      columnNumber = Math.floor((columnNumber - 1) / 26);
    }
    return letter;
  }

  /**
   * Sanitize Filename
   */
  private sanitizeFilename(filename: string): string {
    return filename.replace(/[^a-z0-9]/gi, '_').toLowerCase();
  }

  /**
   * List Generated Reports
   */
  listReports(): string[] {
    if (!fs.existsSync(this.outputDir)) {
      return [];
    }

    return fs.readdirSync(this.outputDir).filter(file => {
      return file.endsWith('.pdf') || file.endsWith('.xlsx') || file.endsWith('.csv');
    });
  }

  /**
   * Delete Report
   */
  deleteReport(filename: string): boolean {
    const filepath = path.join(this.outputDir, filename);

    if (fs.existsSync(filepath)) {
      fs.unlinkSync(filepath);
      console.log(`✓ Report deleted: ${filename}`);
      return true;
    }

    return false;
  }
}

// Export factory function
export function createReportGenerator(config: ReportConfig) {
  return new ReportGenerator(config);
}
