"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReportGenerator = void 0;
exports.createReportGenerator = createReportGenerator;
const PDFDocument = __importStar(require("pdfkit"));
const ExcelJS = __importStar(require("exceljs"));
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
class ReportGenerator {
    constructor(config) {
        this.config = {
            author: 'System AI',
            outputPath: './reports',
            ...config,
        };
        this.outputDir = this.config.outputPath || './reports';
        this.ensureOutputDirectory();
    }
    /**
     * Ensure Output Directory Exists
     */
    ensureOutputDirectory() {
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, { recursive: true });
            console.log(`✓ Reports directory created: ${this.outputDir}`);
        }
    }
    /**
     * Generate PDF Report
     */
    async generatePDF(data) {
        return new Promise((resolve, reject) => {
            const filename = `${this.sanitizeFilename(this.config.title)}_${Date.now()}.pdf`;
            const filepath = path.join(this.outputDir, filename);
            // @ts-ignore - PDFDocument has complex type definitions
            const doc = new PDFDocument({
                size: 'A4',
                margin: 50,
            });
            const stream = fs.createWriteStream(filepath);
            doc.pipe(stream);
            // Header
            doc.fontSize(20).text(this.config.title, { align: 'center' });
            doc.moveDown();
            if (this.config.author) {
                doc.fontSize(12).text(`Author: ${this.config.author}`, { align: 'center' });
            }
            doc.fontSize(10).text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' });
            doc.moveDown(2);
            // Summary
            if (data.summary) {
                doc.fontSize(14).text('Summary', { underline: true });
                doc.moveDown(0.5);
                for (const [key, value] of Object.entries(data.summary)) {
                    doc.fontSize(10).text(`${key}: ${value}`);
                }
                doc.moveDown(2);
            }
            // Table
            if (data.headers && data.rows) {
                doc.fontSize(14).text('Data Table', { underline: true });
                doc.moveDown(0.5);
                // Headers
                doc.fontSize(9).font('Helvetica-Bold');
                const headerText = data.headers.join(' | ');
                doc.text(headerText);
                doc.moveDown(0.3);
                // Rows
                doc.font('Helvetica');
                data.rows.forEach((row, idx) => {
                    const rowText = row.join(' | ');
                    doc.text(rowText);
                    if (idx % 5 === 4) {
                        doc.moveDown(0.2);
                    }
                });
            }
            // Footer
            doc.moveDown(2);
            doc.fontSize(8).text('Generated by Intelligent Agent System', {
                align: 'center',
            });
            doc.end();
            stream.on('finish', () => {
                console.log(`✓ PDF report generated: ${filepath}`);
                resolve(filepath);
            });
            stream.on('error', reject);
        });
    }
    /**
     * Generate Excel Report
     */
    async generateExcel(data) {
        const filename = `${this.sanitizeFilename(this.config.title)}_${Date.now()}.xlsx`;
        const filepath = path.join(this.outputDir, filename);
        const workbook = new ExcelJS.Workbook();
        workbook.creator = this.config.author || 'System AI';
        workbook.created = new Date();
        workbook.modified = new Date();
        const worksheet = workbook.addWorksheet(this.config.title.substring(0, 31));
        // Title
        worksheet.mergeCells('A1:' + this.getColumnLetter(data.headers.length) + '1');
        const titleCell = worksheet.getCell('A1');
        titleCell.value = this.config.title;
        titleCell.font = { size: 16, bold: true };
        titleCell.alignment = { horizontal: 'center', vertical: 'middle' };
        // Metadata
        worksheet.mergeCells('A2:' + this.getColumnLetter(data.headers.length) + '2');
        const metaCell = worksheet.getCell('A2');
        metaCell.value = `Generated: ${new Date().toLocaleString()}`;
        metaCell.font = { size: 10 };
        metaCell.alignment = { horizontal: 'center' };
        worksheet.addRow([]);
        // Summary
        if (data.summary) {
            worksheet.addRow(['Summary']).font = { bold: true, size: 12 };
            for (const [key, value] of Object.entries(data.summary)) {
                worksheet.addRow([key, value]);
            }
            worksheet.addRow([]);
        }
        // Headers
        const headerRow = worksheet.addRow(data.headers);
        headerRow.font = { bold: true };
        headerRow.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FF4472C4' },
        };
        headerRow.font = { color: { argb: 'FFFFFFFF' }, bold: true };
        // Data Rows
        data.rows.forEach(row => {
            worksheet.addRow(row);
        });
        // Auto-fit columns
        worksheet.columns.forEach(column => {
            let maxLength = 0;
            column.eachCell?.({ includeEmpty: true }, cell => {
                const length = cell.value ? cell.value.toString().length : 10;
                if (length > maxLength) {
                    maxLength = length;
                }
            });
            column.width = Math.min(maxLength + 2, 50);
        });
        await workbook.xlsx.writeFile(filepath);
        console.log(`✓ Excel report generated: ${filepath}`);
        return filepath;
    }
    /**
     * Generate CSV Report
     */
    async generateCSV(data) {
        const filename = `${this.sanitizeFilename(this.config.title)}_${Date.now()}.csv`;
        const filepath = path.join(this.outputDir, filename);
        let csv = '';
        // Headers
        csv += data.headers.map(h => `"${h}"`).join(',') + '\n';
        // Rows
        data.rows.forEach(row => {
            csv += row.map(cell => `"${cell}"`).join(',') + '\n';
        });
        fs.writeFileSync(filepath, csv, 'utf-8');
        console.log(`✓ CSV report generated: ${filepath}`);
        return filepath;
    }
    /**
     * Generate Report in All Formats
     */
    async generateAll(data) {
        const [pdf, excel, csv] = await Promise.all([
            this.generatePDF(data),
            this.generateExcel(data),
            this.generateCSV(data),
        ]);
        return { pdf, excel, csv };
    }
    /**
     * Generate Process Report
     */
    async generateProcessReport(processes) {
        const headers = ['Process Name', 'Status', 'Duration', 'Steps', 'Created At'];
        const rows = processes.map(p => [
            p.name,
            p.status,
            `${p.duration}s`,
            p.steps?.length || 0,
            new Date(p.createdAt).toLocaleDateString(),
        ]);
        const summary = {
            'Total Processes': processes.length,
            'Completed': processes.filter((p) => p.status === 'completed').length,
            'In Progress': processes.filter((p) => p.status === 'in-progress').length,
            'Average Duration': `${(processes.reduce((sum, p) => sum + (p.duration || 0), 0) / processes.length).toFixed(2)}s`,
        };
        return this.generatePDF({ headers, rows, summary });
    }
    /**
     * Get Column Letter for Excel
     */
    getColumnLetter(columnNumber) {
        let letter = '';
        while (columnNumber > 0) {
            const remainder = (columnNumber - 1) % 26;
            letter = String.fromCharCode(65 + remainder) + letter;
            columnNumber = Math.floor((columnNumber - 1) / 26);
        }
        return letter;
    }
    /**
     * Sanitize Filename
     */
    sanitizeFilename(filename) {
        return filename.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    }
    /**
     * List Generated Reports
     */
    listReports() {
        if (!fs.existsSync(this.outputDir)) {
            return [];
        }
        return fs.readdirSync(this.outputDir).filter(file => {
            return file.endsWith('.pdf') || file.endsWith('.xlsx') || file.endsWith('.csv');
        });
    }
    /**
     * Delete Report
     */
    deleteReport(filename) {
        const filepath = path.join(this.outputDir, filename);
        if (fs.existsSync(filepath)) {
            fs.unlinkSync(filepath);
            console.log(`✓ Report deleted: ${filename}`);
            return true;
        }
        return false;
    }
}
exports.ReportGenerator = ReportGenerator;
// Export factory function
function createReportGenerator(config) {
    return new ReportGenerator(config);
}
